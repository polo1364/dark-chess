<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>象棋暗棋（翻翻棋）</title>
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: "Noto Sans TC", system-ui, -apple-system, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }
  .app {
    width: min(96vw, 680px);
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .header {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
  }
  .title {
    font-size: 28px;
    font-weight: 900;
    text-align: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin: 0 0 16px 0;
  }
  .controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
  }
  button, select {
    border: none;
    border-radius: 12px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 10px 18px;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
  }
  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
  }
  button:active {
    transform: translateY(0);
  }
  select {
    cursor: pointer;
    appearance: none;
    padding-right: 30px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='white' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
  }
  .players {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
  }
  .player-card {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }
  .player-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.25);
  }
  .player-info {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }
  .player-name {
    font-size: 18px;
    font-weight: 800;
    flex: 1;
  }
  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 800;
    color: white;
    min-width: 50px;
  }
  .badge.red { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
  .badge.black { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
  .badge.unknown { background: #e0e0e0; color: #666; }
  .captured {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    min-height: 32px;
  }
  .cap {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 800;
    font-size: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    transition: transform 0.2s ease;
  }
  .cap:hover {
    transform: scale(1.1);
  }
  .cap.red { 
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
  }
  .cap.black { 
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
  }
  .boardWrap {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 24px;
    padding: 24px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
  }
  .board {
    --cols: 8;
    --rows: 4;
    display: grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    gap: 8px;
    aspect-ratio: 8/4;
  }
  .cell {
    background: linear-gradient(145deg, #f5f7fa 0%, #c3cfe2 100%);
    border-radius: 12px;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }
  .cell:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
  }
  .piece {
    width: calc(100% - 12px);
    height: calc(100% - 12px);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 900;
    font-size: 1.4em;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
  }
  .piece.back {
    background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
    color: #2d3436;
  }
  .piece.back::after {
    content: "暗";
    font-weight: 900;
  }
  .piece.red {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }
  .piece.black {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }
  .sel {
    outline: 5px solid #00b894;
    outline-offset: -5px;
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { outline-color: #00b894; }
    50% { outline-color: #55efc4; }
  }
  .hint {
    background: linear-gradient(145deg, #74b9ff 0%, #0984e3 100%);
    box-shadow: 0 0 0 4px rgba(116, 185, 255, 0.3);
  }
  .target {
    background: linear-gradient(145deg, #ff7675 0%, #d63031 100%);
    box-shadow: 0 0 0 4px rgba(255, 118, 117, 0.3);
    animation: targetPulse 1s ease-in-out infinite;
  }
  @keyframes targetPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  .info-panel {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
  }
  .turn-info {
    font-size: 16px;
    font-weight: 700;
    text-align: center;
    color: #2d3436;
    margin-bottom: 16px;
    padding: 12px;
    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
    border-radius: 12px;
  }
  .log {
    height: 140px;
    overflow-y: auto;
    font-size: 13px;
    line-height: 1.6;
    color: #2d3436;
  }
  .log::-webkit-scrollbar {
    width: 6px;
  }
  .log::-webkit-scrollbar-track {
    background: #f1f3f5;
    border-radius: 10px;
  }
  .log::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 10px;
  }
  .log > div {
    padding: 6px 0;
    border-bottom: 1px solid #f1f3f5;
  }
  .log > div:last-child {
    border-bottom: none;
  }
  .who {
    font-weight: 800;
    margin-right: 6px;
    color: #667eea;
  }
  .footer {
    text-align: center;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.9);
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  .overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    z-index: 999;
  }
  .panel {
    background: white;
    border-radius: 24px;
    padding: 32px 40px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    display: flex;
    gap: 16px;
    align-items: center;
    animation: slideUp 0.3s ease;
  }
  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  .panel b {
    font-size: 18px;
    color: #2d3436;
  }
  .spin {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 3px solid #e0e0e0;
    border-top-color: #667eea;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  @media (max-width: 600px) {
    .title { font-size: 24px; }
    .controls { gap: 8px; }
    button, select { padding: 8px 14px; font-size: 13px; }
    .players { grid-template-columns: 1fr; }
    .boardWrap { padding: 16px; }
    .board { gap: 6px; }
  }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h1 class="title">🎮 象棋暗棋</h1>
    <div class="controls">
      <button id="btnNew">🔄 重新開始</button>
      <button id="btnToss">🎲 擲骰決先手</button>
      <select id="mode">
        <option value="hva">👤 人機對戰</option>
        <option value="pvp">👥 雙人對戰</option>
      </select>
      <select id="level" title="AI 強度">
        <option value="0">⚡ 快速</option>
        <option value="1" selected>💪 強力</option>
        <option value="2">🧠 專家</option>
      </select>
      <button id="btnResign">🏳️ 認輸</button>
      <button id="btnRule">📖 規則</button>
    </div>
  </div>

  <div class="players">
    <div class="player-card">
      <div class="player-info">
        <div class="player-name" id="topName">玩家 2</div>
        <div id="topBadge" class="badge unknown">？</div>
      </div>
      <div class="captured" id="topCaps"></div>
    </div>

    <div class="player-card">
      <div class="player-info">
        <div class="player-name" id="botName">玩家 1</div>
        <div id="botBadge" class="badge unknown">？</div>
      </div>
      <div class="captured" id="botCaps"></div>
    </div>
  </div>

  <div class="boardWrap">
    <div id="board" class="board"></div>
  </div>

  <div class="info-panel">
    <div class="turn-info" id="turnInfo">先手未決：請翻子決定顏色</div>
    <div id="log" class="log"></div>
  </div>

  <div class="footer">
    50 手無吃無翻判和 | 點棋選擇/取消 | 兵吃將 | 炮隔一子吃
  </div>
</div>

<div id="thinking" class="overlay">
  <div class="panel">
    <div class="spin"></div>
    <b>AI 思考中…</b>
  </div>
</div>

<div id="result" class="overlay">
  <div class="panel">
    <b id="resultText">對局結束</b>
    <button id="btnNew2">🎮 新局</button>
  </div>
</div>

<script>
(()=>{
  const ROWS=4, COLS=8;
  const CN={R:{G:"帥",A:"仕",E:"相",R:"車",N:"馬",C:"炮",P:"兵"}, B:{G:"將",A:"士",E:"象",R:"車",N:"馬",C:"炮",P:"卒"}};
  const RANK={G:7,A:6,E:5,R:4,N:3,C:2,P:1};
  const VAL={G:1000,A:320,E:260,R:520,N:360,C:420,P:110};
  const MAX_QUIET=50;
  let state, colorsAssigned=false, gameMode='hva', aiLevel=1, aiTimer=null;

  const E=(id)=>document.getElementById(id);
  const show=(el,vis)=>{el.style.display=vis?'flex':'none'};
  const log=(who,txt)=>{const d=document.createElement('div');d.innerHTML=`<span class="who">${who}：</span>${txt}`;E('log').appendChild(d);E('log').scrollTop=E('log').scrollHeight;}
  const setBadge=()=>{const tb=E('topBadge'), bb=E('botBadge'); if(!colorsAssigned){tb.textContent='？';tb.className='badge unknown';bb.textContent='？';bb.className='badge unknown';return;} tb.textContent=state.topColor==='R'?'紅':'黑'; bb.textContent=state.bottomColor==='R'?'紅':'黑'; tb.className='badge '+(state.topColor==='R'?'red':'black'); bb.className='badge '+(state.bottomColor==='R'?'red':'black');};

  const inBoard=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;
  const adj=(r1,c1,r2,c2)=>Math.abs(r1-r2)+Math.abs(c1-c2)===1;
  const between=(r1,c1,r2,c2)=>{
    if(r1!==r2 && c1!==c2) return Infinity;
    let cnt=0;
    if(r1===r2){const[a,b]=c1<c2?[c1,c2]:[c2,c1];for(let x=a+1;x<b;x++) if(state.board[r1][x]) cnt++;}
    else {const[a,b]=r1<r2?[r1,r2]:[r2,r1];for(let y=a+1;y<b;y++) if(state.board[y][c1]) cnt++;}
    return cnt;
  };
  const canCap=(r1,c1,r2,c2)=>{
    const a=state.board[r1][c1], b=state.board[r2][c2];
    if(!a||!b||!a.revealed||!b.revealed||a.color===b.color) return false;
    if(a.type==='C'){ if(r1!==r2&&c1!==c2) return false; return between(r1,c1,r2,c2)===1; }
    if(!adj(r1,c1,r2,c2)) return false;
    if(a.type==='P'&&b.type==='G') return true;
    if(a.type==='G'&&b.type==='P') return false;
    return RANK[a.type]>=RANK[b.type];
  };

  const betweenS=(S,r1,c1,r2,c2)=>{
    if(r1!==r2 && c1!==c2) return Infinity;
    let cnt=0;
    if(r1===r2){const[a,b]=c1<c2?[c1,c2]:[c2,c1];for(let x=a+1;x<b;x++) if(S.board[r1][x]) cnt++;}
    else {const[a,b]=r1<r2?[r1,r2]:[r2,r1];for(let y=a+1;y<b;y++) if(S.board[y][c1]) cnt++;}
    return cnt;
  };
  const canCapS=(S,r1,c1,r2,c2)=>{
    const a=S.board[r1][c1], b=S.board[r2][c2];
    if(!a||!b||!a.revealed||!b.revealed||a.color===b.color) return false;
    if(a.type==='C'){ if(r1!==r2&&c1!==c2) return false; return betweenS(S,r1,c1,r2,c2)===1; }
    if(Math.abs(r1-r2)+Math.abs(c1-c2)!==1) return false;
    if(a.type==='P'&&b.type==='G') return true;
    if(a.type==='G'&&b.type==='P') return false;
    return RANK[a.type]>=RANK[b.type];
  };
  const capsFromS=(S,r,c,color)=>{
    const res=[]; const a=S.board[r][c]; if(!a||!a.revealed||a.color!==color) return res;
    for(const[dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nr=r+dr,nc=c+dc; if(!inBoard(nr,nc)) continue;
      const b=S.board[nr][nc];
      if(b&&b.revealed&&b.color!==color&&canCapS(S,r,c,nr,nc)) res.push({from:{r,c},to:{r:nr,c:nc}});
    }
    if(a.type==='C'){
      for(let x=c+1;x<COLS;x++){ if(S.board[r][x]){ for(let x2=x+1;x2<COLS;x2++){ if(S.board[r][x2]){ const b=S.board[r][x2]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,r,x2)===1) res.push({from:{r,c},to:{r:r,c:x2}}); break; } } break; } }
      for(let x=c-1;x>=0;x--){ if(S.board[r][x]){ for(let x2=x-1;x2>=0;x2--){ if(S.board[r][x2]){ const b=S.board[r][x2]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,r,x2)===1) res.push({from:{r,c},to:{r:r,c:x2}}); break; } } break; } }
      for(let y=r+1;y<ROWS;y++){ if(S.board[y][c]){ for(let y2=y+1;y2<ROWS;y2++){ if(S.board[y2][c]){ const b=S.board[y2][c]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,y2,c)===1) res.push({from:{r,c},to:{r:y2,c:c}}); break; } } break; } }
      for(let y=r-1;y>=0;y--){ if(S.board[y][c]){ for(let y2=y-1;y2>=0;y2--){ if(S.board[y2][c]){ const b=S.board[y2][c]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,y2,c)===1) res.push({from:{r,c},to:{r:y2,c:c}}); break; } } break; } }
    }
    return res;
  };
  const genActsS=(S,color)=>{
    const acts=[];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const p=S.board[r][c]; if(p && !p.revealed) acts.push({kind:'flip',r,c}); }
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const a=S.board[r][c]; if(!a||!a.revealed||a.color!==color) continue;
      for(const[dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nr=r+dr,nc=c+dc; if(!inBoard(nr,nc)) continue; const b=S.board[nr][nc];
        if(!b) acts.push({kind:'move',from:{r,c},to:{r:nr,c:nc}});
        else if(b.revealed&&b.color!==color&&canCapS(S,r,c,nr,nc)) acts.push({kind:'capture',from:{r,c},to:{r:nr,c:nc}});
      }
      if(a.type==='C') for(const m of capsFromS(S,r,c,color)) acts.push({kind:'capture',from:m.from,to:m.to});
    }
    for(const m of acts){
      let s=0;
      if(m.kind==='capture'){ const A=S.board[m.from.r][m.from.c], B=S.board[m.to.r][m.to.c]; s=100000+(B?VAL[B.type]:0)*100-(A?VAL[A.type]:0); }
      else if(m.kind==='move'){ s=1000 + (12-(Math.abs(m.to.r-1.5)+Math.abs(m.to.c-3.5))); }
      else { s=10 + (10-(Math.abs(m.r-1.5)+Math.abs(m.c-3.5))); }
      m._order=s;
    }
    acts.sort((a,b)=>(b._order||0)-(a._order||0));
    return acts;
  };

  const buildBoard=()=>{
    const b=E('board'); b.innerHTML='';
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const d=document.createElement('div'); d.className='cell'; d.dataset.r=r; d.dataset.c=c;
      d.onclick=onCell; b.appendChild(d);
    }
  };
  const newGame=()=>{
    const bag=[]; const push=(col,typ,n)=>{for(let i=0;i<n;i++) bag.push({color:col,type:typ,revealed:false});};
    for(const col of ['R','B']){ push(col,'G',1); push(col,'A',2); push(col,'E',2); push(col,'R',2); push(col,'N',2); push(col,'C',2); push(col,'P',5); }
    for(let i=bag.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; }
    const board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    let k=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) board[r][c]={...bag[k++]};
    state={board,turn:null,bottomColor:'R',topColor:'B',sel:null,capturedR:[],capturedB:[],quiet:0,winner:null,firstMover:null};
    colorsAssigned=false; buildBoard(); draw(true); E('log').innerHTML=''; E('turnInfo').textContent='先手未決：請翻子決定顏色'; show(E('thinking'),false); setBadge();
  };

  const getMover=()=>{ if(!colorsAssigned) return state.firstMover||'human'; if(gameMode==='pvp') return 'human'; return (state.turn===state.bottomColor)?'human':'ai'; };
  const myPiece=(p)=>p&&p.revealed&&(gameMode==='pvp'?p.color===state.turn:(colorsAssigned&&state.turn===state.bottomColor&&p.color===state.bottomColor));
  function onCell(e){
    if(state.winner) return;
    if(gameMode==='hva' && getMover()==='ai') return;
    const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c, p=state.board[r][c];
    if(!colorsAssigned){ if(p && !p.revealed) return firstFlip(r,c,'human'); E('turnInfo').textContent='請先翻子決定顏色'; return; }
    const sel=state.sel;
    if(!sel){ 
      if(p && !p.revealed) return flip(r,c);
      if(p && myPiece(p)){ state.sel={r,c}; draw(); } 
      return; 
    }
    if(sel.r===r&&sel.c===c){ state.sel=null; draw(); return; }
    const a=state.board[sel.r][sel.c];
    if(!p){ if(adj(sel.r,sel.c,r,c)) move(sel.r,sel.c,r,c); else E('turnInfo').textContent='只能橫直一步'; return; }
    if(p.revealed && p.color!==a.color){ if(canCap(sel.r,sel.c,r,c)) capture(sel.r,sel.c,r,c); else E('turnInfo').textContent='此路不通'; return; }
    if(p.revealed && p.color===a.color){ state.sel={r,c}; draw(); }
  }

  const darks=()=>{const d=[];for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const p=state.board[r][c];if(p&&!p.revealed)d.push({r,c});}return d;};
  function firstFlip(r,c,who){
    const p=state.board[r][c]; p.revealed=true; colorsAssigned=true;
    state.bottomColor = (who==='human')? p.color : (p.color==='R'?'B':'R');
    state.topColor = (state.bottomColor==='R')?'B':'R';
    state.turn = (p.color==='R')?'B':'R';
    log(who==='human'?'你':'AI', `翻到【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】；你持【${state.bottomColor==='R'?'紅':'黑'}】`);
    draw(); setBadge(); E('turnInfo').textContent = who==='human'?'輪到對手':'輪到你';
    ensureAI(2000);
  }
  function flip(r,c){ const p=state.board[r][c]; if(!p||p.revealed) return; p.revealed=true; state.quiet=0; log(side(),'翻開【'+(p.color==='R'?'紅':'黑')+CN[p.color==='R'?'R':'B'][p.type]+'】'); draw(); next(); }
  function move(r1,c1,r2,c2){ const a=state.board[r1][c1]; if(!a) return; state.board[r2][c2]={...a}; state.board[r1][c1]=null; state.sel=null; state.quiet++; log(side(),`移動【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】至 (${r2},${c2})`); draw(); next(); }
  function capture(r1,c1,r2,c2){ const a=state.board[r1][c1], b=state.board[r2][c2]; if(!a||!b) return; const taken={...b}; state.board[r2][c2]={...a}; state.board[r1][c1]=null; (taken.color==='R'?state.capturedR:state.capturedB).push(taken); state.sel=null; state.quiet=0; log(side(),`以【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】吃【${b.color==='R'?'紅':'黑'}${CN[b.color==='R'?'R':'B'][b.type]}】`); draw(); next(); }
  const side=()=> getMover()==='human'?'你':(gameMode==='hva'?'AI':'對手');

  function ensureAI(delay=2000){
    if (gameMode!=='hva' || !colorsAssigned || state.winner) return false;
    if (state.turn === state.bottomColor) return false; // player's turn
    if (aiTimer){ clearTimeout(aiTimer); aiTimer=null; }
    E('turnInfo').textContent = 'AI 思考中…';
    show(E('thinking'), true);
    aiTimer = setTimeout(()=>{ aiTimer=null; aiMove(); }, delay);
    return true;
  }

  function aiMove(){
    if (aiTimer){ clearTimeout(aiTimer); aiTimer=null; }
    show(E('thinking'), true);
    try{
      const acts=genActsS(state,state.turn);
      if(!acts.length){ const ds=darks(); if(ds.length){ const k=ds[Math.floor(Math.random()*ds.length)]; apply({kind:'flip',r:k.r,c:k.c},true); } else next(); return; }
      const depth = aiLevel===2?3 : aiLevel===1?2 : 1;
      const best = search(state, depth, state.turn, -1e9, 1e9).move || acts[0];
      apply(best,true);
    }catch(err){
      console.error(err);
      const ds=darks(); if(ds.length){ const k=ds[Math.floor(Math.random()*ds.length)]; apply({kind:'flip',r:k.r,c:k.c},true); } else next();
    }finally{ show(E('thinking'),false); }
  }
  function search(S, depth, color, alpha, beta){
    if(depth===0) return {value:evalPos(S,color)};
    const acts=genActsS(S,color); if(!acts.length) return {value:evalPos(S,color)};
    let best=null, bestVal=-1e9;
    for(const m of acts){
      if(m.kind!=='flip' && !S.board[m.from.r]?.[m.from.c]) continue;
      const snap=clone(S); apply(m,false,snap);
      const val = -search(snap, depth-1, (color==='R'?'B':'R'), -beta, -alpha).value;
      if(val>bestVal){bestVal=val; best=m;}
      if(val>alpha) alpha=val;
      if(alpha>=beta) break;
    }
    return {move:best,value:bestVal};
  }
  function evalPos(S,pov){
    let r=0,b=0,cr=0,cb=0;
    for(let i=0;i<ROWS;i++) for(let j=0;j<COLS;j++){ const p=S.board[i][j]; if(!p||!p.revealed) continue; const c=8-(Math.abs(i-1.5)+Math.abs(j-3.5)); if(p.color==='R'){r+=VAL[p.type];cr+=c;} else {b+=VAL[p.type];cb+=c;} }
    const v=(r-b)+0.12*(cr-cb); return pov==='R'?v:-v;
  }
  function apply(act, real=false, S=null){
    const T=S||state;
    if(act.kind==='flip'){ const p=T.board[act.r][act.c]; if(p&&!p.revealed){ p.revealed=true; T.quiet=0; if(real) log(side(),'翻開【'+(p.color==='R'?'紅':'黑')+CN[p.color==='R'?'R':'B'][p.type]+'】'); } if(real){ draw(); next(); } return; }
    if(act.kind==='move'){ const a=T.board[act.from.r]?.[act.from.c]; if(!a) return; T.board[act.to.r][act.to.c]={...a}; T.board[act.from.r][act.from.c]=null; T.quiet++; if(real){ log(side(),`移動【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】`); draw(); next(); } return; }
    if(act.kind==='capture'){
      if(S){ const a=T.board[act.from.r]?.[act.from.c], b=T.board[act.to.r]?.[act.to.c]; if(!a) return; if(b) (b.color==='R'?T.capturedR:T.capturedB).push({...b}); T.board[act.to.r][act.to.c]={...a}; T.board[act.from.r][act.from.c]=null; T.quiet=0; return; }
      return capture(act.from.r,act.from.c,act.to.r,act.to.c);
    }
  }
  const clone=(s)=>({board:s.board.map(r=>r.map(p=>p?{...p}:null)),turn:s.turn,bottomColor:s.bottomColor,topColor:s.topColor,sel:s.sel?{...s.sel}:null,capturedR:s.capturedR.map(x=>({...x})),capturedB:s.capturedB.map(x=>({...x})),quiet:s.quiet,winner:s.winner,firstMover:s.firstMover});

  function next(){
    state.turn = (state.turn==='R'?'B':'R');
    state.sel=null;
    endCheck();
    if(!state.winner){
      const mv=getMover();
      E('turnInfo').textContent = mv==='human'?'輪到你':'AI 思考中…';
      if(mv==='ai') ensureAI(2000);
    }
  }
  function endCheck(){
    const alive=(col)=>{let n=0;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const p=state.board[r][c];if(p&&p.color===col)n++;}return n;};
    if(alive('R')===0||alive('B')===0){ state.winner=alive('R')===0?'B':'R'; return showEnd(`${state.winner==='R'?'紅':'黑'}勝（全殲）`); }
    if(state.quiet>=MAX_QUIET){ state.winner='D'; return showEnd('和局（50手無吃無翻）'); }
    const hasMoves = genActsS(state,state.turn).length>0; const ds=darks();
    if(ds.length===0 && !hasMoves){ state.winner=(state.turn==='R'?'B':'R'); return showEnd(`${state.winner==='R'?'紅':'黑'}勝（對方無法行棋）`); }
  }
  const showEnd=(txt)=>{E('resultText').textContent=txt+' － 點新局再戰'; show(E('result'),true); show(E('thinking'),false); if(aiTimer){clearTimeout(aiTimer); aiTimer=null;} };

  function draw(init=false){
    const b=E('board').children;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const i=r*COLS+c; const cell=b[i]; cell.classList.remove('sel','hint','target'); cell.innerHTML='';
      const p=state.board[r][c]; if(!p) continue;
      const k=document.createElement('div'); k.className='piece '+(p.revealed?(p.color==='R'?'red':'black'):'back');
      if(p.revealed){ const lab=document.createElement('span'); lab.textContent=(p.color==='R'?CN.R[p.type]:CN.B[p.type]); k.appendChild(lab); }
      cell.appendChild(k);
    }
    if(state.sel){ const {r,c}=state.sel; const idx=r*COLS+c; b[idx].classList.add('sel'); const a=state.board[r][c];
      if(a&&a.revealed){
        for(const[dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){ const nr=r+dr,nc=c+dc; if(!inBoard(nr,nc)) continue; const q=state.board[nr][nc]; if(!q) b[nr*COLS+nc].classList.add('hint'); else if(q.revealed&&q.color!==a.color&&canCap(r,c,nr,nc)) b[nr*COLS+nc].classList.add('target'); }
        if(a.type==='C'){ for(const m of capsFromS(state,r,c,a.color)) b[m.to.r*COLS+m.to.c].classList.add('target'); }
      }
    }
    const pack=(arr)=>{const m=new Map(); for(const p of arr){const k=p.color+p.type; m.set(k,(m.get(k)||0)+1);} return [...m.entries()].map(([k,v])=>({color:k[0],type:k[1],n:v}));};
    const top=(state.topColor==='R')?state.capturedR:state.capturedB, bot=(state.bottomColor==='R')?state.capturedR:state.capturedB;
    const topCaps=E('topCaps'), botCaps=E('botCaps'); topCaps.innerHTML=''; botCaps.innerHTML='';
    for(const x of pack(top)){ const d=document.createElement('div'); d.className='cap '+(x.color==='R'?'red':'black'); d.textContent=(x.color==='R'?CN.R[x.type]:CN.B[x.type]); topCaps.appendChild(d); }
    for(const x of pack(bot)){ const d=document.createElement('div'); d.className='cap '+(x.color==='R'?'red':'black'); d.textContent=(x.color==='R'?CN.R[x.type]:CN.B[x.type]); botCaps.appendChild(d); }
    if(init){ setBadge(); }
  }

  function resign(){ if(state.winner) return; const w=(state.turn==='R'?'B':'R'); state.winner=w; showEnd(`${w==='R'?'紅':'黑'}勝（認輸）`); }

  function decideFirst(w){
    state.firstMover=w;
    if(w==='ai'&&gameMode==='hva'){
      E('turnInfo').textContent='AI 正在翻子…';
      if (aiTimer){ clearTimeout(aiTimer); aiTimer=null; }
      aiTimer = setTimeout(()=>{
        aiTimer=null;
        const ds=darks(); const k=ds[Math.floor(Math.random()*ds.length)];
        firstFlip(k.r,k.c,'ai');
      },2000);
    } else {
      E('turnInfo').textContent='你先手：翻任一枚暗棋';
    }
  }
  function init(){
    E('btnNew').onclick=newGame; E('btnNew2').onclick=()=>{show(E('result'),false); newGame();};
    E('btnResign').onclick=resign; E('btnRule').onclick=()=>alert('先手翻子決色｜每回合一動作（翻/移/吃）｜兵吃將、將不能吃兵｜炮隔一子吃｜50手無吃無翻和局');
    E('mode').onchange=(e)=>{gameMode=e.target.value; E('topName').textContent=(gameMode==='hva'?'電腦':'玩家 2'); E('botName').textContent='玩家 1'; setBadge();};
    E('level').onchange=(e)=>aiLevel=+e.target.value;
    E('btnToss').onclick=()=>decideFirst(Math.random()<0.5?'human':'ai');
    buildBoard(); newGame(); decideFirst('human');
  }
  init();
})();
</script>
</body>
</html>
