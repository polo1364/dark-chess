<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>象棋暗棋（翻翻棋）— 人機對戰</title>
<style>
  :root{
    --bg:#f6f3ee;
    --panel:#ffffffcc;
    --wood1:#c49a6c;
    --wood2:#9b7954;
    --grid:#4b3a29;
    --red:#c0392b;
    --black:#2c3e50;
    --gold:#d4a44b;
    --sel:#2ecc71;
    --hint:#3498db;
    --warn:#e67e22;
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family: "Noto Sans TC","PingFang TC","Microsoft JhengHei","Heiti TC","Source Han Sans TC","Source Han Sans SC","Hiragino Sans GB","Meiryo","Segoe UI",system-ui,-apple-system,sans-serif;
    background: radial-gradient(1000px 700px at 50% -10%, #ffffff, var(--bg));
    color:#222;
    display:flex; justify-content:center; align-items:stretch;
  }
  .app{ width: min(96vw, 540px); padding:12px; display:flex; flex-direction:column; gap:10px; }
  .bar{
    display:flex; gap:8px; align-items:center; justify-content:space-between;
    background: var(--panel); backdrop-filter: blur(6px);
    padding:10px; border-radius:12px; box-shadow: 0 8px 20px #00000014, inset 0 0 0 1px #00000010;
    flex-wrap:wrap;
  }
  .bar .group{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  select,button{ border:1px solid #00000022; background:#fff; border-radius:10px; padding:8px 12px; font-size:14px; cursor:pointer; }
  button.primary{background:linear-gradient(#fff,#f2f2f2); border-color:#00000030}
  button.ghost{background:transparent}
  .names{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
    background: var(--panel); padding:10px; border-radius:12px; box-shadow: 0 8px 20px #00000014, inset 0 0 0 1px #00000010; }
  .player{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
  .name{ font-weight:700; letter-spacing:.5px; }
  .captured{ display:flex; gap:4px; flex-wrap:wrap; justify-content:flex-end; min-height:36px; }
  .cap{ width:28px; height:28px; border-radius:50%; display:flex; align-items:center; justify-content:center;
    font-size:14px; font-weight:700; border:2px solid #00000022; box-shadow: 0 1px 0 #fff inset; background: #fff; position:relative; }
  .cap.red{color:var(--red)} .cap.black{color:var(--black)}
  .cap small{ position:absolute; right:-6px; bottom:-6px; background:#000; color:#fff; font-size:10px; border-radius:10px; padding:0 4px; }
  .boardWrap{
    background: radial-gradient(1200px 800px at 50% -20%, #fff0, #00000010), linear-gradient(115deg, var(--wood1), var(--wood2));
    border-radius:16px; padding:14px; box-shadow: 0 20px 40px #00000025, inset 0 0 0 2px #00000012;
  }
  .board{ --cols:8; --rows:4; display:grid; grid-template-columns: repeat(var(--cols), 1fr); aspect-ratio: 8/4; gap:6px; position:relative; }
  .cell{
    background:linear-gradient(#f8e7cc,#edd3a9); border-radius:10px; border:2px solid var(--grid);
    position:relative; box-shadow: inset 0 0 0 1px #00000020, inset 0 0 10px #00000015;
    display:flex; align-items:center; justify-content:center; user-select:none;
  }
  .coord{position:absolute; font-size:10px; color:#00000055; top:4px; left:6px}
  .piece{
    position:relative;
    width: calc(100% - 10px); height: calc(100% - 10px);
    border-radius:999px; display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size: clamp(16px, 4.3vw, 28px);
    background: radial-gradient(circle at 35% 30%, #fff, #fff2 30%, #00000008 60%), linear-gradient(#fff7,#fff2);
    border:3px solid var(--gold); box-shadow: 0 6px 14px #00000045, inset 0 0 0 1px #fff8;
    letter-spacing:1px; transition: transform .12s ease;
    font-family: "Noto Sans TC","PingFang TC","Microsoft JhengHei","Heiti TC","Source Han Sans TC","Source Han Sans SC","Hiragino Sans GB","Meiryo","Segoe UI",system-ui,-apple-system,sans-serif;
  }
  .piece.red{color:var(--red)} .piece.black{color:var(--black)}
  .piece.back{ background: radial-gradient(circle at 35% 30%, #ffe497, #e6b455 60%), linear-gradient(#fff6,#0000); border-color:#a06a00; }
  .piece.back::after{ content:"暗"; color:#4b2e00; text-shadow:0 1px 0 #fff8; font-weight:900; }
  .piece.revealed{transform: translateY(-1px)}
  .sel{outline: 4px solid var(--sel); outline-offset: -4px}
  .hint{box-shadow: 0 0 0 3px var(--hint) inset, 0 0 0 2px #fff}
  .target{box-shadow: 0 0 0 3px var(--warn) inset, 0 0 0 2px #fff}

  .piece-label{
    position:relative; z-index:3; font-weight:900; font-size:1.35em; line-height:1;
    pointer-events:none;
    text-shadow:0 1px 0 #fff, 0 0 2px #0004, 0 2px 4px #0002;
    -webkit-text-stroke: 1px #fff; opacity:1;
    font-family:'DarkChessCJK', inherit;
  }
  .piece-abbr{position:absolute; right:6px; bottom:6px; font-size:.72em; font-weight:800; opacity:.85; background:#fff8; padding:1px 5px; border-radius:8px; border:1px solid #0001; z-index:4; pointer-events:none;}

  .footer{ display:flex; gap:10px; align-items:center; justify-content:space-between; opacity:.85; font-size:12px; }
  .badge{padding:4px 8px; border-radius:999px; background:#00000008; border:1px solid #00000014}
  .modal{ position: fixed; inset:0; display:none; place-items:center; background:#00000055; z-index:50; }
  .modal.show{display:grid}
  .card{ width:min(92vw,520px); background:#fff; border-radius:16px; padding:16px; box-shadow: 0 30px 60px #00000055; }
  .card h3{margin:4px 0 10px}
  .row{display:flex; gap:8px; flex-wrap:wrap}
  .right{margin-left:auto}
  .tiny{font-size:12px; opacity:.8}
  .link{color:#0b84ff; text-decoration:underline; cursor:pointer}

  /* AI overlay */
  .ai-overlay{position:fixed; inset:0; background:rgba(0,0,0,.28); display:flex; align-items:center; justify-content:center; z-index:99; backdrop-filter: blur(2px);}
  .ai-panel{background:#fff; border-radius:16px; padding:16px 18px; box-shadow:0 20px 50px rgba(0,0,0,.35); display:flex; align-items:center; gap:12px; border:1px solid #0001}
  .spinner{width:22px; height:22px; border-radius:50%; border:3px solid #e5e5e5; border-top-color:#0b84ff; animation:spin 1s linear infinite}
  @keyframes spin {to{transform:rotate(360deg)}}
  .ai-text{font-weight:800; letter-spacing:.5px}
</style>
</head>
<body>
<div class="app">

  <div class="bar">
    <div class="group">
      <button class="primary" id="btnNew">重新開始</button>
      <button id="btnToss">擲骰決先手</button>
      <select id="mode">
        <option value="hva">人機對戰</option>
        <option value="pvp">雙人對戰</option>
      </select>
      <select id="level" title="AI 強度">
        <option value="0">快速</option>
        <option value="1" selected>強</option>
        <option value="2">專家</option>
      </select>
    </div>
    <div class="group">
      <button class="ghost" id="btnRule">規則</button>
    </div>
  </div>

  <!-- 上方玩家（預設：電腦或玩家2） -->
  <div class="names">
    <div class="player" id="topBar">
      <div class="name" id="topName">玩家 2</div>
      <div class="captured" id="topCaps"></div>
    </div>
  </div>

  <div class="boardWrap">
    <div class="board" id="board"></div>
  </div>

  <!-- 下方玩家（預設：玩家1） -->
  <div class="names">
    <div class="player" id="botBar">
      <div class="name" id="botName">玩家 1</div>
      <div class="captured" id="botCaps"></div>
    </div>
  </div>

  <div class="footer">
    <div class="badge" id="turnInfo">先手未決定：第一步需翻子</div>
    <div class="tiny">50 手無吃無翻自動和局｜點棋選擇／再點取消</div>
  </div>

  <!-- AI overlay -->
  <div id="aiOverlay" class="ai-overlay" style="display:none">
    <div class="ai-panel">
      <div class="spinner"></div>
      <div class="ai-text">AI 思考中…</div>
    </div>
  </div>

</div>

<!-- 規則與先手 modal -->
<div class="modal" id="modal">
  <div class="card">
    <h3>遊戲說明</h3>
    <p style="margin:.3em 0 1em">
      先手由擲骰或指定決定；先手第一步必須翻任一暗棋，翻出的顏色即為先手持色。之後輪流行動。
    </p>
    <ul style="margin:.2em 0 1em; line-height:1.6">
      <li>明棋只能上下左右移動一格；<b>炮</b>不吃時也只移動一格。</li>
      <li>一般吃子依階級（將>士>象>車>馬>炮>兵）；可吃同級或更小。</li>
      <li><b>特例：</b>兵可以吃將；將<b>不能</b>吃兵。</li>
      <li><b>炮吃子：</b>需同行同列，中間隔<b>正好一枚</b>任意棋，且不受階級限制。</li>
      <li>不可吃未翻開的棋；需先翻開。</li>
      <li><b>每回合僅能執行一次</b>：翻子、移動一步或吃一枚（<b>不啟用連吃</b>）。</li>
      <li>連續 50 手未發生吃子或翻子判和。</li>
    </ul>
    <div class="row">
      <button id="mStartHuman" class="primary">我先</button>
      <button id="mStartAI" class="primary">AI先</button>
      <button id="mRoll" class="">擲骰決先手</button>
      <span class="right tiny"><span class="link" id="mClose">關閉</span></span>
    </div>
  </div>
</div>

<script>
(() => {
  // --- 常數與字典 ---
  const ROWS = 4, COLS = 8;
  const TYPES = ["G","A","E","R","N","C","P"];
  const CN = { R:{G:"帥",A:"仕",E:"相",R:"車",N:"馬",C:"炮",P:"兵"}, B:{G:"將",A:"士",E:"象",R:"車",N:"馬",C:"炮",P:"卒"} };
  const RANK = {G:7, A:6, E:5, R:4, N:3, C:2, P:1};
  const PIECE_VALUES = {G:1000, A:320, E:260, R:520, N:360, C:420, P:110};
  const MAX_QUIET = 50;

  // --- 狀態 ---
  let state;
  let ui = {};
  let humanBottom = true;
  let gameMode = 'hva'; // 'hva' 人機, 'pvp' 雙人
  let aiLevel = 1;
  let colorsAssigned = false;

  // --- 初始化 ---
  function newGame(){
    // 建立32子：紅黑各16（**展開加入**，避免出現陣列包陣列）
    const bag = [];
    ["R","B"].forEach(color=>{
      bag.push(...mk(color,"G",1));
      bag.push(...mk(color,"A",2));
      bag.push(...mk(color,"E",2));
      bag.push(...mk(color,"R",2));
      bag.push(...mk(color,"N",2));
      bag.push(...mk(color,"C",2));
      bag.push(...mk(color,"P",5));
    });
    shuffle(bag);
    const board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
    let idx = 0;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        board[r][c] = {...bag[idx++], r, c, revealed:false};
      }
    }
    state = {
      board,
      turn: null,
      bottomColor: 'R',
      topColor: 'B',
      selected: null,
      history: [],
      capturedR: [], capturedB: [],
      quiet: 0,
      winner: null,
    };
    colorsAssigned = false;
    renderAll(true);
    showModal(true);
    setTurnInfo("先手未決定：先手第一步需翻子");
    showThinking(false);
  }

  function mk(color, type, count){
    return Array.from({length:count}, ()=>({color, type, id:color+type+Math.random().toString(36).slice(2,7)}));
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  // --- UI 建構 ---
  function buildUI(){
    ui.board = document.getElementById('board');
    ui.topCaps = document.getElementById('topCaps');
    ui.botCaps = document.getElementById('botCaps');
    ui.topName = document.getElementById('topName');
    ui.botName = document.getElementById('botName');
    ui.turnInfo = document.getElementById('turnInfo');
    ui.btnNew = document.getElementById('btnNew');
    ui.btnToss = document.getElementById('btnToss');
    ui.btnRule = document.getElementById('btnRule');
    ui.modal = document.getElementById('modal');
    ui.mStartHuman = document.getElementById('mStartHuman');
    ui.mStartAI = document.getElementById('mStartAI');
    ui.mRoll = document.getElementById('mRoll');
    ui.mClose = document.getElementById('mClose');
    ui.modeSel = document.getElementById('mode');
    ui.levelSel = document.getElementById('level');

    ui.btnNew.onclick = newGame;
    ui.btnToss.onclick = ()=> showModal(true);
    ui.btnRule.onclick = ()=> showModal(true);
    ui.mClose.onclick = ()=> showModal(false);
    ui.mStartHuman.onclick = ()=> decideFirst('human');
    ui.mStartAI.onclick = ()=> decideFirst('ai');
    ui.mRoll.onclick = ()=> decideFirst(Math.random()<0.5 ? 'human' : 'ai');
    ui.modeSel.onchange = (e)=> { gameMode = e.target.value; renderAll(); if (gameMode==='hva'){ui.topName.textContent='電腦'; ui.botName.textContent='玩家 1'} else {ui.topName.textContent='玩家 2'; ui.botName.textContent='玩家 1'} }
    ui.levelSel.onchange = (e)=> { aiLevel = +e.target.value }

    // 建格
    ui.board.innerHTML = '';
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className = 'cell'; cell.dataset.r=r; cell.dataset.c=c;
        const coord = document.createElement('div'); coord.className='coord'; coord.textContent = `${r},${c}`;
        cell.appendChild(coord);
        cell.addEventListener('click', onCellClick);
        ui.board.appendChild(cell);
      }
    }
  }

  function showModal(v){ ui.modal.classList.toggle('show', !!v) }
  function showThinking(v){ const o=document.getElementById('aiOverlay'); if(!o) return; o.style.display = v? 'flex':'none'; }

  function decideFirst(who){
    showModal(false);
    if (gameMode==='hva'){ humanBottom = true; ui.topName.textContent = '電腦'; ui.botName.textContent = '玩家 1'; }
    else { ui.topName.textContent = '玩家 2'; ui.botName.textContent = '玩家 1'; }
    state.firstMover = who;
    setTurnInfo( (who==='human') ? '你先手：請翻任一暗棋決定持色' : 'AI先手：AI 正在翻子…');
    colorsAssigned = false;
    if (who==='ai' && gameMode==='hva'){ setTimeout(()=> aiActFirstFlip(), 300); }
  }

  function onCellClick(e){
    if (state.winner) return;
    if (gameMode==='hva' && currentSideToMoveIsAI()) return;
    const r = +e.currentTarget.dataset.r, c = +e.currentTarget.dataset.c;
    const piece = state.board[r][c];

    // 首翻決色
    if (!colorsAssigned){
      if (!piece) return;
      if (!piece.revealed){
        firstFlipAssignColors(r,c,'human');
        return;
      } else { setTurnInfo('請先翻任一暗棋決定持色'); return; }
    }

    const sel = state.selected;

    // 點暗棋 → 翻子（單步回合）
    if (piece && !piece.revealed){
      doFlip(r,c); return;
    }

    if (!sel){
      if (piece && piece.revealed && isMyTurnPiece(piece)){
        state.selected = {r,c}; renderAll(); return;
      }
      return;
    } else {
      if (sel.r===r && sel.c===c){ state.selected=null; renderAll(); return; }
      const fromP = state.board[sel.r][sel.c];
      if (!fromP || !fromP.revealed){ state.selected=null; renderAll(); return; }

      // 空格 → 移動一步
      if (!piece){
        if (isAdjacent(sel.r, sel.c, r, c)){ doMove(sel.r, sel.c, r, c); } else { blinkInfo('只能移動一格'); }
        return;
      }
      // 敵棋 → 嘗試吃（單步回合）
      if (piece && piece.revealed && piece.color!==fromP.color){
        if (canCapture(sel.r, sel.c, r, c)){ doCapture(sel.r, sel.c, r, c, false); } else { blinkInfo('此路不通'); }
        return;
      }
      // 己棋 → 切換選擇
      if (piece && piece.color===fromP.color && piece.revealed){ state.selected={r,c}; renderAll(); return; }
    }
  }

  function currentSideToMoveIsAI(){
    if (gameMode!=='hva') return false;
    const mover = getMover();
    return (mover==='ai');
  }
  function getMover(){
    if (!colorsAssigned) return state.firstMover || 'human';
    if (gameMode==='pvp') return 'human';
    const turnColor = state.turn;
    const humanColor = state.bottomColor;
    return (turnColor===humanColor) ? 'human' : 'ai';
  }
  function isMyTurnPiece(p){
    if (!p || !p.revealed) return false;
    if (gameMode==='pvp') return p.color===state.turn;
    if (!colorsAssigned) return false;
    const humanTurn = (state.turn === state.bottomColor);
    return humanTurn && (p.color === state.bottomColor);
  }


  // --- 首翻 / 翻子 ---
  function aiActFirstFlip(){
    const darks = darkSquares();
    const pick = darks[Math.floor(Math.random()*darks.length)];
    firstFlipAssignColors(pick.r, pick.c, 'ai');
  }
  function darkSquares(){ const arr=[]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const p=state.board[r][c]; if(p && !p.revealed) arr.push({r,c}); } return arr; }
  function firstFlipAssignColors(r,c, who){
    const p = state.board[r][c]; if(!p || p.revealed) return;
    p.revealed = true; colorsAssigned = true;
    state.bottomColor = (who==='human') ? p.color : (p.color==='R'?'B':'R');
    state.topColor = (state.bottomColor==='R'?'B':'R');
    state.turn = (p.color==='R'?'B':'R'); // 翻子後換對手
    state.selected = null; state.quiet = 0;
    pushHistory({kind:'flip', r,c, piece:p});
    renderAll();

    const msg = (who==='human')
      ? `你翻到【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】→ 你持【${state.bottomColor==='R'?'紅':'黑'}】；輪到對手`
      : `AI 翻到【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】→ 你持【${state.bottomColor==='R'?'紅':'黑'}】；輪到你`;
    setTurnInfo(msg);

    if (currentSideToMoveIsAI()){ setTimeout(aiMove, 220); showThinking(true); }
  }

  function doFlip(r,c){
    const p = state.board[r][c]; if(!p || p.revealed) return;
    p.revealed = true; state.quiet = 0; pushHistory({kind:'flip', r,c, piece:p});
    setTurnInfo(`${sideLabel(state.turn)} 翻開了【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】`);
    renderAll(); nextTurn();
  }

  function sideLabel(){ const mover = getMover(); return mover==='human' ? '你' : (gameMode==='hva'?'AI':'對手'); }

  // --- 移動 / 吃子 ---
  function isAdjacent(r1,c1,r2,c2){ return Math.abs(r1-r2) + Math.abs(c1-c2) === 1; }
  function isCannon(p){ return p?.type==='C' }
  function betweenCount(r1,c1,r2,c2){
    if (r1!==r2 && c1!==c2) return Infinity;
    let cnt=0;
    if (r1===r2){ const [a,b] = c1<c2 ? [c1,c2] : [c2,c1]; for (let x=a+1;x<b;x++) if (state.board[r1][x]) cnt++; }
    else { const [a,b] = r1<r2 ? [r1,r2] : [r2,r1]; for (let y=a+1;y<b;y++) if (state.board[y][c1]) cnt++; }
    return cnt;
  }
  function canCapture(r1,c1,r2,c2){
    const a = state.board[r1][c1], b = state.board[r2][c2];
    if (!a || !b || !a.revealed || !b.revealed || a.color===b.color) return false;
    if (isCannon(a)){ if (r1!==r2 && c1!==c2) return false; return betweenCount(r1,c1,r2,c2)===1; }
    if (!isAdjacent(r1,c1,r2,c2)) return false;
    if (a.type==='P' && b.type==='G') return true;
    if (a.type==='G' && b.type==='P') return false;
    return RANK[a.type] >= RANK[b.type];
  }
  function doMove(r1,c1,r2,c2){
    const a = state.board[r1][c1]; if(!a) return;
    if (!isAdjacent(r1,c1,r2,c2)) return; if (state.board[r2][c2]) return;
    state.board[r2][c2] = {...a, r:r2, c:c2}; state.board[r1][c1] = null;
    state.selected = null; state.quiet++; pushHistory({kind:'move', from:{r:r1,c:c1}, to:{r:r2,c:c2}, piece:state.board[r2][c2]});
    renderAll(); nextTurn();
  }
  function doCapture(r1,c1,r2,c2){
    const a = state.board[r1][c1], b = state.board[r2][c2]; if(!a||!b) return;
    if (!canCapture(r1,c1,r2,c2)) return;
    const taken = {...b};
    state.board[r2][c2] = {...a, r:r2, c:c2}; state.board[r1][c1] = null;
    (taken.color==='R' ? state.capturedR : state.capturedB).push(taken);
    state.selected = null; state.quiet = 0; pushHistory({kind:'capture', from:{r:r1,c:c1}, to:{r:r2,c:c2}, piece:state.board[r2][c2], taken});
    renderAll();
    // 單步規則：吃完就換手
    nextTurn();
  }

  // --- AI ---
  function aiMove(){
    showThinking(true);
    try{
      if (state.winner) return;
      const color = state.turn;
      let moves = generateAllActions(color);
      if (!moves || moves.length===0){
        const ds = darkSquares();
        if (ds.length>0){
          const pick = ds[Math.floor(Math.random()*ds.length)];
          moves = [{kind:'flip', r:pick.r, c:pick.c}];
        }
      }
      if (!moves || moves.length===0){
        state.winner = (color==='R'?'B':'R');
        setTurnInfo(`AI 無法行棋，${state.winner==='R'?'紅':'黑'}勝`);
        renderAll();
        return;
      }
      let best = null;
      if (aiLevel===0){ best = pickByHeuristic(moves, color); }
      else {
        const depth = (aiLevel===1)? 2 : 3;
        const {move} = searchBest(state, depth, color, -1e9, 1e9);
        best = move || pickByHeuristic(moves, color);
      }
      applyAction(best, true);
    } catch(e){
      console.error('AI error', e);
      const ds = darkSquares();
      if (ds.length){
        const k = ds[Math.floor(Math.random()*ds.length)];
        applyAction({kind:'flip', r:k.r, c:k.c}, true);
      } else {
        nextTurn();
      }
    } finally { showThinking(false); }
  }

  function generateAllActions(color){
    const acts = [];
    // 翻子
    for (const d of darkSquares()) acts.push({kind:'flip', r:d.r, c:d.c});
    // 移動/吃子
    for (let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const a = state.board[r][c];
      if (!a || !a.revealed || a.color!==color) continue;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,dc] of dirs){
        const nr=r+dr, nc=c+dc; if (!inBoard(nr,nc)) continue;
        const b = state.board[nr][nc];
        if (!b) acts.push({kind:'move', from:{r,c}, to:{r:nr,c:nc}});
        else if (b.revealed && b.color!==color && canCapture(r,c,nr,nc)) acts.push({kind:'capture', from:{r,c}, to:{r:nr,c:nc}});
      }
      if (state.board[r][c].type==='C'){
        const caps = legalCapturesFrom(r,c,color);
        for (const m of caps) acts.push({kind:'capture', from:m.from, to:m.to});
      }
    }
    return acts;
  }

  function pickByHeuristic(moves, color){
    function score(act){
      if (act.kind==='capture'){
        const a = pieceAt(act.from.r, act.from.c);
        const b = pieceAt(act.to.r, act.to.c);
        const gain = PIECE_VALUES[b.type] - Math.floor(PIECE_VALUES[a.type]*0.85);
        return 10000 + gain;
      }
      if (act.kind==='move'){
        const centerBias = 20 - manhattan(act.to.r,act.to.c, 1.5,3.5); return centerBias;
      }
      if (act.kind==='flip'){
        const centerBias = 14 - manhattan(act.r,act.c,1.5,3.5); return 5 + centerBias;
      }
      return 0;
    }
    let best=moves[0], bestS=-1e9;
    for (const m of moves){ const s=score(m); if (s>bestS){bestS=s; best=m;} }
    return best;
  }

  function searchBest(s0, depth, color, alpha, beta){
    const moves = generateAllActions(color);
    let best = null, bestVal = -1e9;
    for (const m of moves){
      const snap = snapshot(s0);
      applyAction(m, false, snap);
      let val;
      if (depth<=1){ val = evaluate(snap, color); }
      else {
        const opp = color==='R'?'B':'R';
        const res = searchBest(snap, depth-1, opp, -beta, -alpha);
        val = -res.value;
      }
      if (val>bestVal){ bestVal=val; best=m }
      alpha = Math.max(alpha, val);
      if (alpha>=beta) break;
    }
    return {move:best, value:bestVal};
  }

  // 評估
  function evaluate(snap, povColor){
    let matR=0, matB=0, mobR=0, mobB=0, centR=0, centB=0;
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const p = snap.board[r][c]; if (!p) continue;
      const side = (p.color==='R') ? {mat:()=>matR+=PIECE_VALUES[p.type], cent:()=>centR+=centerScore(r,c)} : {mat:()=>matB+=PIECE_VALUES[p.type], cent:()=>centB+=centerScore(r,c)};
      if (p.revealed){ side.mat(); side.cent(); }
    }
    function mobility(color){
      const saved = state; state = snap; const acts = generateAllActions(color); state = saved;
      let eat = acts.filter(a=>a.kind==='capture').length;
      let move = acts.filter(a=>a.kind==='move').length;
      return eat*6 + move*1;
    }
    mobR = mobility('R'); mobB = mobility('B');
    const val = (matR-matB) + 0.12*(mobR-mobB) + 0.08*(centR-centB) + flipHeuristic(snap,povColor);
    return (povColor==='R') ? val : -val;
  }
  function centerScore(r,c){ return 12 - manhattan(r,c,1.5,3.5) }
  function manhattan(r,c, r2,c2){ return Math.abs(r-r2)+Math.abs(c-c2) }
  function flipHeuristic(snap, color){ let dark=0; for (let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const p=snap.board[r][c]; if (p && !p.revealed) dark++; } return Math.min(40, dark*0.8); }

  // 動作套用
  function applyAction(act, real=false, snap=null){
    const S = snap || state;
    if (act.kind==='flip'){
      const p = S.board[act.r][act.c]; if (p && !p.revealed){ p.revealed=true; S.quiet=0; if(real) pushHistory({kind:'flip', r:act.r, c:act.c, piece:p}); }
      if (real){ renderAll(); nextTurn(); }
      return;
    }
    if (act.kind==='move'){
      const a = S.board[act.from.r][act.from.c]; if (!a) return;
      S.board[act.to.r][act.to.c] = {...a, r:act.to.r, c:act.to.c}; S.board[act.from.r][act.from.c] = null; S.quiet++; if (real){ pushHistory({kind:'move', from:act.from, to:act.to, piece:S.board[act.to.r][act.to.c]}); renderAll(); nextTurn(); }
      return;
    }
    if (act.kind==='capture'){
      if (snap){ applyCaptureOnSnap(S, act.from.r, act.from.c, act.to.r, act.to.c); return; }
      doCapture(act.from.r, act.from.c, act.to.r, act.to.c, false);
    }
  }
  function applyCaptureOnSnap(S, r1,c1,r2,c2){
    const a=S.board[r1][c1], b=S.board[r2][c2];
    S.board[r2][c2] = {...a, r:r2, c:c2}; S.board[r1][c1] = null; (b.color==='R'?S.capturedR:S.capturedB).push(b); S.quiet=0;
  }
  function snapshot(s){ return { board: s.board.map(row=> row.map(p=> p? {...p}:null )), turn:s.turn, bottomColor:s.bottomColor, topColor:s.topColor, selected:s.selected? {...s.selected}:null, history:[], capturedR:s.capturedR.map(x=>({...x})), capturedB:s.capturedB.map(x=>({...x})), quiet:s.quiet, winner:s.winner, firstMover:s.firstMover }; }
  function pieceAt(r,c){ return state.board[r][c]; }
  function pushHistory(h){ state.history.push(h) }

  // 勝負/和局
  function checkEnd(){
    if (state.winner) return;
    const aliveR = countAlive('R'), aliveB = countAlive('B');
    if (aliveR===0 || aliveB===0){ state.winner = (aliveR===0)? 'B':'R'; setTurnInfo(`${state.winner==='R'?'紅':'黑'}勝（全殲）`); renderAll(); return; }
    if (state.quiet >= MAX_QUIET){ state.winner = 'D'; setTurnInfo('和局（50手無吃無翻）'); renderAll(); return; }
    const darks = darkSquares(); const hasMoves = generateAllActions(state.turn).length>0;
    if (darks.length===0 && !hasMoves){ state.winner = (state.turn==='R'?'B':'R'); setTurnInfo(`${state.winner==='R'?'紅':'黑'}勝（對方無法行棋）`); renderAll(); return; }
  }
  function countAlive(color){
    let n=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){ const p = state.board[r][c]; if (p && p.color===color) n++; } return n;
  }

  // 畫面
  function renderAll(initial=false){ renderBoard(); renderCaptured(); if (initial) renderNames(); }
  function renderNames(){ ui.topName.style.color = state.topColor==='R'? 'var(--red)':'var(--black)'; ui.botName.style.color = state.bottomColor==='R'? 'var(--red)':'var(--black)'; }
  function renderCaptured(){
    function pack(list){ const m = new Map(); for (const p of list){ const key=p.color+p.type; m.set(key,(m.get(key)||0)+1); }
      const arr=[]; for(const [k,v] of m.entries()){ const color=k[0]==='R'?'R':'B'; const type=k[1]; arr.push({color,type,count:v}); } arr.sort((a,b)=> PIECE_VALUES[b.type]-PIECE_VALUES[a.type]); return arr; }
    const topTaken = (state.topColor==='R') ? state.capturedR : state.capturedB;
    const botTaken = (state.bottomColor==='R') ? state.capturedR : state.capturedB;
    ui.topCaps.innerHTML=''; for(const x of pack(topTaken)){ const el=document.createElement('div'); el.className='cap '+(x.color==='R'?'red':'black'); el.textContent = CN[x.color==='R'?'R':'B'][x.type]; const s=document.createElement('small'); s.textContent='×'+x.count; el.appendChild(s); ui.topCaps.appendChild(el); }
    ui.botCaps.innerHTML=''; for(const x of pack(botTaken)){ const el=document.createElement('div'); el.className='cap '+(x.color==='R'?'red':'black'); el.textContent = CN[x.color==='R'?'R':'B'][x.type]; const s=document.createElement('small'); s.textContent='×'+x.count; el.appendChild(s); ui.botCaps.appendChild(el); }
  }
  function renderBoard(){
    const cells = ui.board.children;
    for (const cell of cells) cell.classList.remove('sel','hint','target');
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const idx = r*COLS+c; const cell = cells[idx]; cell.innerHTML='';
      const coord = document.createElement('div'); coord.className='coord'; coord.textContent=`${r},${c}`; cell.appendChild(coord);
      const p = state.board[r][c];
      if (p){
        const k = document.createElement('div');
        if (!p.revealed){ k.className='piece back'; }
        else { k.className='piece revealed '+(p.color==='R'?'red':'black'); const lab=document.createElement('span'); lab.className='piece-label'; lab.textContent = (p.color==='R'? CN.R[p.type] : CN.B[p.type]) || p.type; const ab=document.createElement('small'); ab.className='piece-abbr'; ab.textContent=p.type; k.appendChild(lab); k.appendChild(ab); }
        cell.appendChild(k);
      }
    }
    if (state.selected){
      const {r,c} = state.selected; const idx = r*COLS+c; cells[idx].classList.add('sel');
      const p = state.board[r][c];
      if (p && p.revealed){
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc; if (!inBoard(nr,nc)) continue;
          const b = state.board[nr][nc];
          if (!b) cells[nr*COLS+nc].classList.add('hint');
          else if (b.revealed && b.color!==p.color && canCapture(r,c,nr,nc)) cells[nr*COLS+nc].classList.add('target');
        }
        if (isCannon(p)){ const caps = legalCapturesFrom(r,c,p.color); for (const m of caps){ cells[m.to.r*COLS+m.to.c].classList.add('target'); } }
      }
    }
  }
  function legalCapturesFrom(r,c,color){
    const res=[]; const a = state.board[r][c]; if(!a || a.color!==color) return res;
    // 一般子四鄰
    if (!isCannon(a)){
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,dc] of dirs){ const nr=r+dr, nc=c+dc; if(!inBoard(nr,nc)) continue; const b=state.board[nr][nc]; if(b && b.revealed && b.color!==color && canCapture(r,c,nr,nc)) res.push({from:{r,c}, to:{r:nr,c:nc}}); }
    } else {
      // 炮遠吃
      for(let x=c+1;x<COLS;x++){ if(state.board[r][x]){ for(let x2=x+1;x2<COLS;x2++){ if(state.board[r][x2]){ const b=state.board[r][x2]; if (b.revealed && b.color!==color && betweenCount(r,c,r,x2)===1) res.push({from:{r,c}, to:{r:r,c:x2}}); break; } } break; } }
      for(let x=c-1;x>=0;x--){ if(state.board[r][x]){ for(let x2=x-1;x2>=0;x2--){ if(state.board[r][x2]){ const b=state.board[r][x2]; if (b.revealed && b.color!==color && betweenCount(r,c,r,x2)===1) res.push({from:{r,c}, to:{r:r,c:x2}}); break; } } break; } }
      for(let y=r+1;y<ROWS;y++){ if(state.board[y][c]){ for(let y2=y+1;y2<ROWS;y2++){ if(state.board[y2][c]){ const b=state.board[y2][c]; if (b.revealed && b.color!==color && betweenCount(r,c,y2,c)===1) res.push({from:{r,c}, to:{r:y2,c:c}}); break; } } break; } }
      for(let y=r-1;y>=0;y--){ if(state.board[y][c]){ for(let y2=y-1;y2>=0;y2--){ if(state.board[y2][c]){ const b=state.board[y2][c]; if (b.revealed && b.color!==color && betweenCount(r,c,y2,c)===1) res.push({from:{r,c}, to:{r:y2,c:c}}); break; } } break; } }
    }
    return res;
  }
  function inBoard(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS }

  function setTurnInfo(msg){ ui.turnInfo.textContent = msg }
  function blinkInfo(msg){ setTurnInfo(msg); ui.turnInfo.animate([{opacity:0.3},{opacity:1}],{duration:260,iterations:2}); }

  function nextTurn(){
    state.turn = (state.turn==='R' ? 'B' : 'R');
    state.selected = null;
    showThinking(false);
    checkEnd();
    if (!state.winner){
      const mover = getMover();
      setTurnInfo( mover==='human' ? '輪到你' : 'AI 思考中…' );
      showThinking(mover!=='human');
      renderAll();
      if (currentSideToMoveIsAI()){ setTimeout(aiMove, 220); }
    }
  }

  // 啟動
  function init(){ buildUI(); newGame(); }
  function renderNames(){ ui.topName.style.color = state.topColor==='R'? 'var(--red)':'var(--black)'; ui.botName.style.color = state.bottomColor==='R'? 'var(--red)':'var(--black)'; }

  init();
})();
</script>
</body>
</html>
