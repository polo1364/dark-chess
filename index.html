<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>象棋暗棋（翻翻棋）</title>
<style>
  body{margin:0;font-family:"Noto Sans TC",system-ui,-apple-system,sans-serif;background:#f6f3ee;color:#222;display:flex;justify-content:center}
  .app{width:min(96vw,560px);padding:12px;display:flex;flex-direction:column;gap:10px}
  .bar,.names,.log{background:#ffffffcc;border-radius:12px;box-shadow:0 8px 20px #0001, inset 0 0 0 1px #0001}
  .bar{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px;flex-wrap:wrap}
  .names{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:10px}
  .player{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .name{font-weight:800}
  .badge{display:inline-block;margin-left:6px;padding:2px 8px;border-radius:999px;font-size:12px;font-weight:800;color:#fff}
  .badge.red{background:#c0392b}.badge.black{background:#2c3e50}
  .captured{display:flex;gap:4px;flex-wrap:wrap;justify-content:flex-end;min-height:28px}
  .cap{width:24px;height:24px;border-radius:50%;display:flex;align-items:center;justify-content:center;border:2px solid #0002;background:#fff;font-weight:800}
  .cap.red{color:#c0392b}.cap.black{color:#2c3e50}
  .boardWrap{background:linear-gradient(115deg,#c49a6c,#9b7954);border-radius:16px;padding:12px;box-shadow:0 20px 40px #0003, inset 0 0 0 2px #0002}
  .board{--cols:8;--rows:4;display:grid;grid-template-columns:repeat(var(--cols),1fr);gap:6px;aspect-ratio:8/4}
  .cell{background:linear-gradient(#f8e7cc,#edd3a9);border-radius:10px;border:2px solid #4b3a29;position:relative;display:flex;align-items:center;justify-content:center}
  .piece{width:calc(100% - 10px);height:calc(100% - 10px);border-radius:999px;display:flex;align-items:center;justify-content:center;border:3px solid #d4a44b;background:#fff;font-weight:900;box-shadow:0 6px 14px #0005}
  .piece.back{background:linear-gradient(#ffe497,#e6b455);border-color:#a06a00;color:#4b2e00}
  .piece.back::after{content:"暗";font-weight:900}
  .piece.red{color:#c0392b}.piece.black{color:#2c3e50}
  .label{font-size:1.3em;-webkit-text-stroke:1px #fff;text-shadow:0 1px 0 #fff,0 0 2px #0004,0 2px 4px #0002}
  .sel{outline:4px solid #2ecc71;outline-offset:-4px}
  .hint{box-shadow:0 0 0 3px #3498db inset,0 0 0 2px #fff}
  .target{box-shadow:0 0 0 3px #e67e22 inset,0 0 0 2px #fff}
  .log{padding:10px;height:120px;overflow:auto;font-size:12.5px}
  .who{font-weight:800;margin-right:4px}
  .footer{display:flex;justify-content:space-between;align-items:center;font-size:12px;opacity:.85}
  button,select{border:1px solid #0002;border-radius:10px;background:#fff;padding:6px 10px}
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.28);z-index:9}
  .panel{background:#fff;border-radius:14px;padding:14px 16px;box-shadow:0 20px 40px #0006;border:1px solid #0001;display:flex;gap:10px;align-items:center}
  .spin{width:20px;height:20px;border-radius:50%;border:3px solid #e5e5e5;border-top-color:#0b84ff;animation:sp 1s linear infinite}
  @keyframes sp{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<div class="app">
  <div class="bar">
    <div>
      <button id="btnNew">重新開始</button>
      <button id="btnToss">擲骰決先手</button>
      <select id="mode"><option value="hva">人機</option><option value="pvp">雙人</option></select>
      <select id="level" title="AI 強度"><option value="0">快</option><option value="1" selected>強</option><option value="2">專家</option></select>
    </div>
    <div>
      <button id="btnResign">認輸</button>
      <button id="btnRule">規則</button>
    </div>
  </div>

  <div class="names">
    <div class="player"><div class="name" id="topName">玩家 2 <span id="topBadge" class="badge">？</span></div></div>
    <div class="captured" id="topCaps"></div>
  </div>

  <div class="boardWrap"><div id="board" class="board"></div></div>

  <div id="log" class="log"></div>

  <div class="names">
    <div class="player"><div class="name" id="botName">玩家 1 <span id="botBadge" class="badge">？</span></div></div>
    <div class="captured" id="botCaps"></div>
  </div>

  <div class="footer">
    <div id="turnInfo">先手未決：請翻子決定顏色</div>
    <div>50 手無吃無翻判和｜點棋選擇/取消</div>
  </div>
</div>

<div id="thinking" class="overlay"><div class="panel"><div class="spin"></div><b>AI 思考中…</b></div></div>
<div id="result" class="overlay"><div class="panel"><b id="resultText">對局結束</b><button id="btnNew2">新局</button></div></div>

<script>
(()=>{
  const ROWS=4, COLS=8;
  const CN={R:{G:"帥",A:"仕",E:"相",R:"車",N:"馬",C:"炮",P:"兵"}, B:{G:"將",A:"士",E:"象",R:"車",N:"馬",C:"炮",P:"卒"}};
  const RANK={G:7,A:6,E:5,R:4,N:3,C:2,P:1};
  const VAL={G:1000,A:320,E:260,R:520,N:360,C:420,P:110};
  const MAX_QUIET=50;
  let state, colorsAssigned=false, gameMode='hva', aiLevel=1;

  const E=(id)=>document.getElementById(id);
  const show=(el,vis)=>{el.style.display=vis?'flex':'none'};
  const log=(who,txt)=>{const d=document.createElement('div');d.innerHTML=`<span class="who">${who}：</span>${txt}`;E('log').appendChild(d);E('log').scrollTop=E('log').scrollHeight;}
  const setBadge=()=>{const tb=E('topBadge'), bb=E('botBadge'); if(!colorsAssigned){tb.textContent='？';tb.className='badge';bb.textContent='？';bb.className='badge';return;} tb.textContent=state.topColor==='R'?'紅':'黑'; bb.textContent=state.bottomColor==='R'?'紅':'黑'; tb.className='badge '+(state.topColor==='R'?'red':'black'); bb.className='badge '+(state.bottomColor==='R'?'red':'black');};

  const inBoard=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;
  const adj=(r1,c1,r2,c2)=>Math.abs(r1-r2)+Math.abs(c1-c2)===1;
  const between=(r1,c1,r2,c2)=>{
    if(r1!==r2 && c1!==c2) return Infinity;
    let cnt=0;
    if(r1===r2){const[a,b]=c1<c2?[c1,c2]:[c2,c1];for(let x=a+1;x<b;x++) if(state.board[r1][x]) cnt++;}
    else {const[a,b]=r1<r2?[r1,r2]:[r2,r1];for(let y=a+1;y<b;y++) if(state.board[y][c1]) cnt++;}
    return cnt;
  };
  const canCap=(r1,c1,r2,c2)=>{
    const a=state.board[r1][c1], b=state.board[r2][c2];
    if(!a||!b||!a.revealed||!b.revealed||a.color===b.color) return false;
    if(a.type==='C'){ if(r1!==r2&&c1!==c2) return false; return between(r1,c1,r2,c2)===1; }
    if(!adj(r1,c1,r2,c2)) return false;
    if(a.type==='P'&&b.type==='G') return true;
    if(a.type==='G'&&b.type==='P') return false;
    return RANK[a.type]>=RANK[b.type];
  };

  const betweenS=(S,r1,c1,r2,c2)=>{
    if(r1!==r2 && c1!==c2) return Infinity;
    let cnt=0;
    if(r1===r2){const[a,b]=c1<c2?[c1,c2]:[c2,c1];for(let x=a+1;x<b;x++) if(S.board[r1][x]) cnt++;}
    else {const[a,b]=r1<r2?[r1,r2]:[r2,r1];for(let y=a+1;y<b;y++) if(S.board[y][c1]) cnt++;}
    return cnt;
  };
  const canCapS=(S,r1,c1,r2,c2)=>{
    const a=S.board[r1][c1], b=S.board[r2][c2];
    if(!a||!b||!a.revealed||!b.revealed||a.color===b.color) return false;
    if(a.type==='C'){ if(r1!==r2&&c1!==c2) return false; return betweenS(S,r1,c1,r2,c2)===1; }
    if(Math.abs(r1-r2)+Math.abs(c1-c2)!==1) return false;
    if(a.type==='P'&&b.type==='G') return true;
    if(a.type==='G'&&b.type==='P') return false;
    return RANK[a.type]>=RANK[b.type];
  };
  const capsFromS=(S,r,c,color)=>{
    const res=[]; const a=S.board[r][c]; if(!a||!a.revealed||a.color!==color) return res;
    for(const[dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nr=r+dr,nc=c+dc; if(!inBoard(nr,nc)) continue;
      const b=S.board[nr][nc];
      if(b&&b.revealed&&b.color!==color&&canCapS(S,r,c,nr,nc)) res.push({from:{r,c},to:{r:nr,c:nc}});
    }
    if(a.type==='C'){
      for(let x=c+1;x<COLS;x++){ if(S.board[r][x]){ for(let x2=x+1;x2<COLS;x2++){ if(S.board[r][x2]){ const b=S.board[r][x2]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,r,x2)===1) res.push({from:{r,c},to:{r:r,c:x2}}); break; } } break; } }
      for(let x=c-1;x>=0;x--){ if(S.board[r][x]){ for(let x2=x-1;x2>=0;x2--){ if(S.board[r][x2]){ const b=S.board[r][x2]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,r,x2)===1) res.push({from:{r,c},to:{r:r,c:x2}}); break; } } break; } }
      for(let y=r+1;y<ROWS;y++){ if(S.board[y][c]){ for(let y2=y+1;y2<ROWS;y2++){ if(S.board[y2][c]){ const b=S.board[y2][c]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,y2,c)===1) res.push({from:{r,c},to:{r:y2,c:c}}); break; } } break; } }
      for(let y=r-1;y>=0;y--){ if(S.board[y][c]){ for(let y2=y-1;y2>=0;y2--){ if(S.board[y2][c]){ const b=S.board[y2][c]; if(b.revealed&&b.color!==color&&betweenS(S,r,c,y2,c)===1) res.push({from:{r,c},to:{r:y2,c:c}}); break; } } break; } }
    }
    return res;
  };
  const genActsS=(S,color)=>{
    const acts=[];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const p=S.board[r][c]; if(p && !p.revealed) acts.push({kind:'flip',r,c}); }
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const a=S.board[r][c]; if(!a||!a.revealed||a.color!==color) continue;
      for(const[dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nr=r+dr,nc=c+dc; if(!inBoard(nr,nc)) continue; const b=S.board[nr][nc];
        if(!b) acts.push({kind:'move',from:{r,c},to:{r:nr,c:nc}});
        else if(b.revealed&&b.color!==color&&canCapS(S,r,c,nr,nc)) acts.push({kind:'capture',from:{r,c},to:{r:nr,c:nc}});
      }
      if(a.type==='C') for(const m of capsFromS(S,r,c,color)) acts.push({kind:'capture',from:m.from,to:m.to});
    }
    for(const m of acts){
      let s=0;
      if(m.kind==='capture'){ const A=S.board[m.from.r][m.from.c], B=S.board[m.to.r][m.to.c]; s=100000+(B?VAL[B.type]:0)*100-(A?VAL[A.type]:0); }
      else if(m.kind==='move'){ s=1000 + (12-(Math.abs(m.to.r-1.5)+Math.abs(m.to.c-3.5))); }
      else { s=10 + (10-(Math.abs(m.r-1.5)+Math.abs(m.c-3.5))); }
      m._order=s;
    }
    acts.sort((a,b)=>(b._order||0)-(a._order||0));
    return acts;
  };

  const buildBoard=()=>{
    const b=E('board'); b.innerHTML='';
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const d=document.createElement('div'); d.className='cell'; d.dataset.r=r; d.dataset.c=c;
      d.onclick=onCell; b.appendChild(d);
    }
  };
  const newGame=()=>{
    const bag=[]; const push=(col,typ,n)=>{for(let i=0;i<n;i++) bag.push({color:col,type:typ,revealed:false});};
    for(const col of ['R','B']){ push(col,'G',1); push(col,'A',2); push(col,'E',2); push(col,'R',2); push(col,'N',2); push(col,'C',2); push(col,'P',5); }
    for(let i=bag.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; }
    const board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    let k=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) board[r][c]={...bag[k++]};
    state={board,turn:null,bottomColor:'R',topColor:'B',sel:null,capturedR:[],capturedB:[],quiet:0,winner:null,firstMover:null};
    colorsAssigned=false; buildBoard(); draw(true); E('log').innerHTML=''; E('turnInfo').textContent='先手未決：請翻子決定顏色'; show(E('thinking'),false); setBadge();
  };

  const getMover=()=>{ if(!colorsAssigned) return state.firstMover||'human'; if(gameMode==='pvp') return 'human'; return (state.turn===state.bottomColor)?'human':'ai'; };
  const myPiece=(p)=>p&&p.revealed&&(gameMode==='pvp'?p.color===state.turn:(colorsAssigned&&state.turn===state.bottomColor&&p.color===state.bottomColor));
  function onCell(e){
    if(state.winner) return;
    if(gameMode==='hva' && getMover()==='ai') return;
    const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c, p=state.board[r][c];
    if(!colorsAssigned){ if(p && !p.revealed) return firstFlip(r,c,'human'); E('turnInfo').textContent='請先翻子決定顏色'; return; }
    const sel=state.sel;
    if(p && !p.revealed) return flip(r,c);
    if(!sel){ if(p && myPiece(p)){ state.sel={r,c}; draw(); } return; }
    if(sel.r===r&&sel.c===c){ state.sel=null; draw(); return; }
    const a=state.board[sel.r][sel.c];
    if(!p){ if(adj(sel.r,sel.c,r,c)) move(sel.r,sel.c,r,c); else E('turnInfo').textContent='只能橫直一步'; return; }
    if(p.revealed && p.color!==a.color){ if(canCap(sel.r,sel.c,r,c)) capture(sel.r,sel.c,r,c); else E('turnInfo').textContent='此路不通'; return; }
    if(p.revealed && p.color===a.color){ state.sel={r,c}; draw(); }
  }

  const darks=()=>{const d=[];for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const p=state.board[r][c];if(p&&!p.revealed)d.push({r,c});}return d;};
  function firstFlip(r,c,who){
    const p=state.board[r][c]; p.revealed=true; colorsAssigned=true;
    state.bottomColor = (who==='human')? p.color : (p.color==='R'?'B':'R');
    state.topColor = (state.bottomColor==='R')?'B':'R';
    state.turn = (p.color==='R')?'B':'R';
    log(who==='human'?'你':'AI', `翻到【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】；你持【${state.bottomColor==='R'?'紅':'黑'}】`);
    draw(); setBadge(); E('turnInfo').textContent = who==='human'?'輪到對手':'輪到你'; ensureAI();
  }
  function flip(r,c){ const p=state.board[r][c]; if(!p||p.revealed) return; p.revealed=true; state.quiet=0; log(side(),'翻開【'+(p.color==='R'?'紅':'黑')+CN[p.color==='R'?'R':'B'][p.type]+'】'); draw(); next(); ensureAI(); }
  function move(r1,c1,r2,c2){ const a=state.board[r1][c1]; if(!a) return; state.board[r2][c2]={...a}; state.board[r1][c1]=null; state.sel=null; state.quiet++; log(side(),`移動【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】至 (${r2},${c2})`); draw(); next(); ensureAI(); }
  function capture(r1,c1,r2,c2){ const a=state.board[r1][c1], b=state.board[r2][c2]; if(!a||!b) return; const taken={...b}; state.board[r2][c2]={...a}; state.board[r1][c1]=null; (taken.color==='R'?state.capturedR:state.capturedB).push(taken); state.sel=null; state.quiet=0; log(side(),`以【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】吃【${b.color==='R'?'紅':'黑'}${CN[b.color==='R'?'R':'B'][b.type]}】`); draw(); next(); ensureAI(); }
  const side=()=> getMover()==='human'?'你':(gameMode==='hva'?'AI':'對手');

  function aiMove(){
    show(E('thinking'),true);
    try{
      const acts=genActsS(state,state.turn);
      if(!acts.length){ const ds=darks(); if(ds.length){ const k=ds[Math.floor(Math.random()*ds.length)]; apply({kind:'flip',r:k.r,c:k.c},true); } else next(); return; }
      const depth = aiLevel===2?3 : aiLevel===1?2 : 1;
      const best = search(state, depth, state.turn, -1e9, 1e9).move || acts[0];
      apply(best,true);
    }catch(err){
      console.error(err);
      const ds=darks(); if(ds.length){ const k=ds[Math.floor(Math.random()*ds.length)]; apply({kind:'flip',r:k.r,c:k.c},true); } else next();
    }finally{ show(E('thinking'),false); }
  }
  function search(S, depth, color, alpha, beta){
    if(depth===0) return {value:evalPos(S,color)};
    const acts=genActsS(S,color); if(!acts.length) return {value:evalPos(S,color)};
    let best=null, bestVal=-1e9;
    for(const m of acts){
      if(m.kind!=='flip' && !S.board[m.from.r]?.[m.from.c]) continue;
      const snap=clone(S); apply(m,false,snap);
      const val = -search(snap, depth-1, (color==='R'?'B':'R'), -beta, -alpha).value;
      if(val>bestVal){bestVal=val; best=m;}
      if(val>alpha) alpha=val;
      if(alpha>=beta) break;
    }
    return {move:best,value:bestVal};
  }
  function evalPos(S,pov){
    let r=0,b=0,cr=0,cb=0;
    for(let i=0;i<ROWS;i++) for(let j=0;j<COLS;j++){ const p=S.board[i][j]; if(!p||!p.revealed) continue; const c=8-(Math.abs(i-1.5)+Math.abs(j-3.5)); if(p.color==='R'){r+=VAL[p.type];cr+=c;} else {b+=VAL[p.type];cb+=c;} }
    const v=(r-b)+0.12*(cr-cb); return pov==='R'?v:-v;
  }
  function apply(act, real=false, S=null){
    const T=S||state;
    if(act.kind==='flip'){ const p=T.board[act.r][act.c]; if(p&&!p.revealed){ p.revealed=true; T.quiet=0; if(real) log(side(),'翻開【'+(p.color==='R'?'紅':'黑')+CN[p.color==='R'?'R':'B'][p.type]+'】'); } if(real){ draw(); next(); } return; }
    if(act.kind==='move'){ const a=T.board[act.from.r]?.[act.from.c]; if(!a) return; T.board[act.to.r][act.to.c]={...a}; T.board[act.from.r][act.from.c]=null; T.quiet++; if(real){ log(side(),`移動【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】`); draw(); next(); } return; }
    if(act.kind==='capture'){
      if(S){ const a=T.board[act.from.r]?.[act.from.c], b=T.board[act.to.r]?.[act.to.c]; if(!a) return; if(b) (b.color==='R'?T.capturedR:T.capturedB).push({...b}); T.board[act.to.r][act.to.c]={...a}; T.board[act.from.r][act.from.c]=null; T.quiet=0; return; }
      return capture(act.from.r,act.from.c,act.to.r,act.to.c);
    }
  }
  const clone=(s)=>({board:s.board.map(r=>r.map(p=>p?{...p}:null)),turn:s.turn,bottomColor:s.bottomColor,topColor:s.topColor,sel:s.sel?{...s.sel}:null,capturedR:s.capturedR.map(x=>({...x})),capturedB:s.capturedB.map(x=>({...x})),quiet:s.quiet,winner:s.winner,firstMover:s.firstMover});

  function ensureAI(){ if(gameMode==='hva'&&colorsAssigned&&!state.winner&&state.turn!==state.bottomColor){ setTimeout(aiMove,150); } }
  function next(){ state.turn = (state.turn==='R'?'B':'R'); state.sel=null; endCheck(); if(!state.winner){ const mv=getMover(); E('turnInfo').textContent = mv==='human'?'輪到你':'AI 思考中…'; if(mv==='ai') setTimeout(aiMove,200); } }
  function endCheck(){
    const alive=(col)=>{let n=0;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const p=state.board[r][c];if(p&&p.color===col)n++;}return n;};
    if(alive('R')===0||alive('B')===0){ state.winner=alive('R')===0?'B':'R'; return showEnd(`${state.winner==='R'?'紅':'黑'}勝（全殲）`); }
    if(state.quiet>=MAX_QUIET){ state.winner='D'; return showEnd('和局（50手無吃無翻）'); }
    const hasMoves = genActsS(state,state.turn).length>0; const ds=darks();
    if(ds.length===0 && !hasMoves){ state.winner=(state.turn==='R'?'B':'R'); return showEnd(`${state.winner==='R'?'紅':'黑'}勝（對方無法行棋）`); }
  }
  const showEnd=(txt)=>{E('resultText').textContent=txt+' － 點新局再戰'; show(E('result'),true)};

  function draw(init=false){
    const b=E('board').children;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const i=r*COLS+c; const cell=b[i]; cell.classList.remove('sel','hint','target'); cell.innerHTML='';
      const p=state.board[r][c]; if(!p) continue;
      const k=document.createElement('div'); k.className='piece '+(p.revealed?(p.color==='R'?'red':'black'):'back');
      if(p.revealed){ const lab=document.createElement('span'); lab.className='label'; lab.textContent=(p.color==='R'?CN.R[p.type]:CN.B[p.type]); k.appendChild(lab); }
      cell.appendChild(k);
    }
    if(state.sel){ const {r,c}=state.sel; const idx=r*COLS+c; b[idx].classList.add('sel'); const a=state.board[r][c];
      if(a&&a.revealed){
        for(const[dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){ const nr=r+dr,nc=c+dc; if(!inBoard(nr,nc)) continue; const q=state.board[nr][nc]; if(!q) b[nr*COLS+nc].classList.add('hint'); else if(q.revealed&&q.color!==a.color&&canCap(r,c,nr,nc)) b[nr*COLS+nc].classList.add('target'); }
        if(a.type==='C'){ for(const m of capsFromS(state,r,c,a.color)) b[m.to.r*COLS+m.to.c].classList.add('target'); }
      }
    }
    const pack=(arr)=>{const m=new Map(); for(const p of arr){const k=p.color+p.type; m.set(k,(m.get(k)||0)+1);} return [...m.entries()].map(([k,v])=>({color:k[0],type:k[1],n:v}));};
    const top=(state.topColor==='R')?state.capturedR:state.capturedB, bot=(state.bottomColor==='R')?state.capturedR:state.capturedB;
    const topCaps=E('topCaps'), botCaps=E('botCaps'); topCaps.innerHTML=''; botCaps.innerHTML='';
    for(const x of pack(top)){ const d=document.createElement('div'); d.className='cap '+(x.color==='R'?'red':'black'); d.textContent=(x.color==='R'?CN.R[x.type]:CN.B[x.type]); topCaps.appendChild(d); }
    for(const x of pack(bot)){ const d=document.createElement('div'); d.className='cap '+(x.color==='R'?'red':'black'); d.textContent=(x.color==='R'?CN.R[x.type]:CN.B[x.type]); botCaps.appendChild(d); }
    if(init){ E('topName').style.color=state.topColor==='R'?'#c0392b':'#2c3e50'; E('botName').style.color=state.bottomColor==='R'?'#c0392b':'#2c3e50'; setBadge(); }
  }

  function resign(){ if(state.winner) return; const w=(state.turn==='R'?'B':'R'); state.winner=w; showEnd(`${w==='R'?'紅':'黑'}勝（認輸）`); }

  function decideFirst(w){ state.firstMover=w; if(w==='ai'&&gameMode==='hva'){ E('turnInfo').textContent='AI 正在翻子…'; setTimeout(()=>{const ds=darks(); const k=ds[Math.floor(Math.random()*ds.length)]; firstFlip(k.r,k.c,'ai');},220);} else { E('turnInfo').textContent='你先手：翻任一枚暗棋'; } }
  function init(){
    E('btnNew').onclick=newGame; E('btnNew2').onclick=()=>{show(E('result'),false); newGame();};
    E('btnResign').onclick=resign; E('btnRule').onclick=()=>alert('先手翻子決色｜每回合一動作（翻/移/吃）｜兵吃將、將不能吃兵｜炮隔一子吃｜50手無吃無翻和局');
    E('mode').onchange=(e)=>{gameMode=e.target.value; E('topName').textContent=(gameMode==='hva'?'電腦':'玩家 2'); E('botName').textContent='玩家 1'; setBadge();};
    E('level').onchange=(e)=>aiLevel=+e.target.value;
    E('btnToss').onclick=()=>decideFirst(Math.random()<0.5?'human':'ai');
    buildBoard(); newGame(); decideFirst('human');
  }
  init();
})();
</script>
</body>
</html>
