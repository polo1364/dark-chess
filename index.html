<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>象棋暗棋（翻翻棋）— 人機對戰</title>
<style>
  :root{
    --bg:#f6f3ee; --panel:#ffffffcc; --wood1:#c49a6c; --wood2:#9b7954; --grid:#4b3a29;
    --red:#c0392b; --black:#2c3e50; --gold:#d4a44b; --sel:#2ecc71; --hint:#3498db; --warn:#e67e22;
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family: "Noto Sans TC","PingFang TC","Microsoft JhengHei","Heiti TC","Source Han Sans TC","Source Han Sans SC","Hiragino Sans GB","Meiryo","Segoe UI",system-ui,-apple-system,sans-serif;
    background: radial-gradient(1000px 700px at 50% -10%, #ffffff, var(--bg));
    color:#222; display:flex; justify-content:center; align-items:stretch;
  }
  .app{ width: min(96vw, 560px); padding:12px; display:flex; flex-direction:column; gap:10px; }

  .bar{
    display:flex; gap:8px; align-items:center; justify-content:space-between;
    background: var(--panel); backdrop-filter: blur(6px);
    padding:10px; border-radius:12px; box-shadow: 0 8px 20px #00000014, inset 0 0 0 1px #00000010;
    flex-wrap:wrap;
  }
  .bar .group{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  select,button{ border:1px solid #00000022; background:#fff; border-radius:10px; padding:8px 12px; font-size:14px; cursor:pointer; }
  button.primary{background:linear-gradient(#fff,#f2f2f2); border-color:#00000030}
  button.ghost{background:transparent}

  .names{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
    background: var(--panel); padding:10px; border-radius:12px; box-shadow: 0 8px 20px #00000014, inset 0 0 0 1px #00000010; }
  .player{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
  .name{ font-weight:700; letter-spacing:.5px; }
  .color-badge{display:inline-block; margin-left:6px; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:800; border:1px solid #00000020; background:#fff; color:#444}
  .color-badge.red{color:#fff; background: #c0392b; border-color:#a03023}
  .color-badge.black{color:#fff; background: #2c3e50; border-color:#223344}
  .captured{ display:flex; gap:4px; flex-wrap:wrap; justify-content:flex-end; min-height:36px; }
  .cap{ width:28px; height:28px; border-radius:50%; display:flex; align-items:center; justify-content:center;
    font-size:14px; font-weight:700; border:2px solid #00000022; box-shadow: 0 1px 0 #fff inset; background: #fff; position:relative; }
  .cap.red{color:var(--red)} .cap.black{color:var(--black)}
  .cap small{ position:absolute; right:-6px; bottom:-6px; background:#000; color:#fff; font-size:10px; border-radius:10px; padding:0 4px; }

  .boardWrap{
    background: radial-gradient(1200px 800px at 50% -20%, #fff0, #00000010), linear-gradient(115deg, var(--wood1), var(--wood2));
    border-radius:16px; padding:14px; box-shadow: 0 20px 40px #00000025, inset 0 0 0 2px #00000012;
  }
  .board{ --cols:8; --rows:4; display:grid; grid-template-columns: repeat(var(--cols), 1fr); aspect-ratio: 8/4; gap:6px; position:relative; }
  .cell{
    background:linear-gradient(#f8e7cc,#edd3a9); border-radius:10px; border:2px solid var(--grid);
    position:relative; box-shadow: inset 0 0 0 1px #00000020, inset 0 0 10px #00000015;
    display:flex; align-items:center; justify-content:center; user-select:none;
  }
  .coord{position:absolute; font-size:10px; color:#00000055; top:4px; left:6px}
  .piece{
    position:relative;
    width: calc(100% - 10px); height: calc(100% - 10px);
    border-radius:999px; display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size: clamp(16px, 4.3vw, 28px);
    background: radial-gradient(circle at 35% 30%, #fff, #fff2 30%, #00000008 60%), linear-gradient(#fff7,#fff2);
    border:3px solid var(--gold); box-shadow: 0 6px 14px #00000045, inset 0 0 0 1px #fff8;
    letter-spacing:1px; transition: transform .12s ease;
    font-family: "Noto Sans TC","PingFang TC","Microsoft JhengHei","Heiti TC","Source Han Sans TC","Source Han Sans SC","Hiragino Sans GB","Meiryo","Segoe UI",system-ui,-apple-system,sans-serif;
  }
  .piece.red{color:var(--red)} .piece.black{color:var(--black)}
  .piece.back{ background: radial-gradient(circle at 35% 30%, #ffe497, #e6b455 60%), linear-gradient(#fff6,#0000); border-color:#a06a00; }
  .piece.back::after{ content:"暗"; color:#4b2e00; text-shadow:0 1px 0 #fff8; font-weight:900; }
  .piece.revealed{transform: translateY(-1px)}
  .sel{outline: 4px solid var(--sel); outline-offset: -4px}
  .hint{box-shadow: 0 0 0 3px var(--hint) inset, 0 0 0 2px #fff}
  .target{box-shadow: 0 0 0 3px var(--warn) inset, 0 0 0 2px #fff}

  .piece-label{
    position:relative; z-index:3; font-weight:900; font-size:1.35em; line-height:1;
    pointer-events:none; color:currentColor; opacity:1;
    text-shadow:0 1px 0 #fff, 0 0 2px #0004, 0 2px 4px #0002;
    -webkit-text-stroke: 1px #fff;
    font-family:'DarkChessCJK', inherit;
  }

  .footer{ display:flex; gap:10px; align-items:center; justify-content:space-between; opacity:.85; font-size:12px; }
  .badge{padding:4px 8px; border-radius:999px; background:#00000008; border:1px solid #00000014}
  .log{background: var(--panel); backdrop-filter: blur(6px); padding:10px; border-radius:12px; box-shadow: 0 8px 20px #00000014, inset 0 0 0 1px #00000010; height:120px; overflow:auto; font-size:12.5px; line-height:1.5}
  .log .item{margin:2px 0}
  .log .who{font-weight:800; margin-right:4px}

  /* AI overlay (non-blocking) */
  .ai-overlay{position:fixed; inset:0; background:rgba(0,0,0,.28); display:flex; align-items:center; justify-content:center; z-index:99; backdrop-filter: blur(2px); pointer-events:none;}
  .ai-panel{background:#fff; border-radius:16px; padding:16px 18px; box-shadow:0 20px 50px rgba(0,0,0,.35); display:flex; align-items:center; gap:12px; border:1px solid #0001}
  .spinner{width:22px; height:22px; border-radius:50%; border:3px solid #e5e5e5; border-top-color:#0b84ff; animation:spin 1s linear infinite}
  @keyframes spin {to{transform:rotate(360deg)}}
  .ai-text{font-weight:800; letter-spacing:.5px}
</style>
</head>
<body>
<div class="app">

  <div class="bar">
    <div class="group">
      <button class="primary" id="btnNew">重新開始</button>
      <button id="btnToss">擲骰決先手</button>
      <select id="mode">
        <option value="hva">人機對戰</option>
        <option value="pvp">雙人對戰</option>
      </select>
      <select id="level" title="AI 強度">
        <option value="0">快速</option>
        <option value="1" selected>強</option>
        <option value="2">專家</option>
      </select>
    </div>
    <div class="group">
      <button class="ghost" id="btnResign">認輸</button>
      <button class="ghost" id="btnRule">規則</button>
    </div>
  </div>

  <!-- 上方玩家 -->
  <div class="names">
    <div class="player" id="topBar">
      <div class="name" id="topName">玩家 2 <span id="topBadge" class="color-badge">？</span></div>
      <div class="captured" id="topCaps"></div>
    </div>
  </div>

  <div class="boardWrap"><div class="board" id="board"></div></div>

  <!-- 提示欄 -->
  <div class="log" id="log"></div>

  <!-- 下方玩家 -->
  <div class="names">
    <div class="player" id="botBar">
      <div class="name" id="botName">玩家 1 <span id="botBadge" class="color-badge">？</span></div>
      <div class="captured" id="botCaps"></div>
    </div>
  </div>

  <div class="footer">
    <div class="badge" id="turnInfo">先手未決定：第一步需翻子</div>
    <div class="tiny">50 手無吃無翻自動和局｜點棋選擇／再點取消</div>
  </div>

  <!-- AI overlay -->
  <div id="aiOverlay" class="ai-overlay" style="display:none">
    <div class="ai-panel">
      <div class="spinner"></div>
      <div class="ai-text">AI 思考中…</div>
    </div>
  </div>

  <!-- 結果 overlay -->
  <div id="resultOverlay" class="ai-overlay" style="display:none; pointer-events:auto">
    <div class="ai-panel">
      <div class="ai-text" id="resultText">對局結束</div>
      <button class="primary" id="btnNew2" style="margin-left:8px">新局</button>
    </div>
  </div>

</div>

<!-- 規則與先手 modal -->
<div class="modal" id="modal" style="position: fixed; inset:0; display:none; place-items:center; background:#00000055; z-index:50;">
  <div class="card" style="width:min(92vw,520px); background:#fff; border-radius:16px; padding:16px; box-shadow: 0 30px 60px #00000055;">
    <h3>遊戲說明</h3>
    <p style="margin:.3em 0 1em">先手由擲骰或指定決定；先手第一步必須翻任一暗棋，翻出的顏色即為先手持色。之後輪流行動。</p>
    <ul style="margin:.2em 0 1em; line-height:1.6">
      <li>明棋只能上下左右移動一格；<b>炮</b>不吃時也只移動一格。</li>
      <li>一般吃子依階級（將>士>象>車>馬>炮>兵）；可吃同級或更小。</li>
      <li><b>特例：</b>兵可以吃將；將<b>不能</b>吃兵。</li>
      <li><b>炮吃子：</b>需同行同列，中間隔<b>正好一枚</b>任意棋，且不受階級限制。</li>
      <li>不可吃未翻開的棋；需先翻開。</li>
      <li><b>每回合僅能執行一次</b>：翻子、移動一步或吃一枚（<b>不啟用連吃</b>）。</li>
      <li>連續 50 手未發生吃子或翻子判和。</li>
    </ul>
    <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="mStartHuman" class="primary">我先</button>
      <button id="mStartAI" class="primary">AI先</button>
      <button id="mRoll">擲骰決先手</button>
      <span class="right tiny" style="margin-left:auto;opacity:.8"><span class="link" id="mClose">關閉</span></span>
    </div>
  </div>
</div>

<script>
(() => {
  // --- 常數與字典 ---
  const ROWS = 4, COLS = 8;
  const TYPES = ["G","A","E","R","N","C","P"];
  const CN = { R:{G:"帥",A:"仕",E:"相",R:"車",N:"馬",C:"炮",P:"兵"}, B:{G:"將",A:"士",E:"象",R:"車",N:"馬",C:"炮",P:"卒"} };
  const RANK = {G:7, A:6, E:5, R:4, N:3, C:2, P:1};
  const PIECE_VALUES = {G:1000, A:320, E:260, R:520, N:360, C:420, P:110};
  const MAX_QUIET = 50;
  // --- AI 強化：Zobrist、TT、歷史啟發、殺手著法 ---
  const RNG = (()=>{ let s=0x9e3779b97f4a7c15n; return ()=> (s=(s^(s>>12n)^(s<<25n)^(s>>27n))*0x94d049bb133111ebn) & ((1n<<64n)-1n); })();
  const ZOBRIST = (()=>{
    const t={};
    for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
      for(const col of ['R','B']) for(const typ of TYPES) t[`p_${r}_${c}_${col}_${typ}`]=Number(RNG());
      t[`rev_${r}_${c}`]=Number(RNG());
    }
    t.sideR = Number(RNG());
    return t;
  })();
  function hashPos(S){
    let h=0|0;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const p=S.board[r][c]; if(!p) continue;
      h ^= ZOBRIST[`p_${r}_${c}_${p.color}_${p.type}`]|0;
      if (p.revealed) h ^= ZOBRIST[`rev_${r}_${c}`]|0;
    }
    if (S.turn==='R') h ^= ZOBRIST.sideR|0;
    return h>>>0;
  }
  const TT = new Map(); // key -> {depth, value, move, flag}
  const KILLERS = Array.from({length:32},()=>[]);
  const HISTORY = {}; // key "from-to" -> score
  function histKey(m){ return `${m.from?rpad(m.from.r,1):'f'}${m.from?m.from.c:'f'}_${m.to?m.to.r:'t'}${m.to?m.to.c:'t'}_${m.kind}` }
  function rpad(n,len){ return (''+n).padStart(len,'0') }

  function nowMs(){ return performance.now() }


  // --- 狀態與 UI ---
  let state; let ui = {};
  let humanBottom = true;
  let gameMode = 'hva'; // 'hva' 人機, 'pvp' 雙人
  let aiLevel = 1;
  let colorsAssigned = false;

  // --- 工具與 UI ---
  function showModal(v){ document.getElementById('modal').style.display = v?'grid':'none'; }
  function showThinking(v){ const o=document.getElementById('aiOverlay'); if(!o) return; o.style.display = v? 'flex':'none'; }
  function setName(el, text){
    if (!el) return;
    let tn = null;
    for (const n of el.childNodes){ if (n.nodeType===3){ tn=n; break; } }
    const s = text.endsWith(' ') ? text : (text+' ');
    if (tn) tn.nodeValue = s; else el.insertBefore(document.createTextNode(s), el.firstChild);
  }

  function setTurnInfo(msg){ ui.turnInfo.textContent = msg }
  function blinkInfo(msg){ setTurnInfo(msg); ui.turnInfo.animate([{opacity:0.3},{opacity:1}],{duration:260,iterations:2}); }
  function inBoard(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS }
  function sideLabel(){ const mover = getMover(); return mover==='human' ? '你' : (gameMode==='hva'?'AI':'對手'); }
  function logAdd(msg, who='系統'){
    const div = document.createElement('div'); div.className='item';
    const whoEl = document.createElement('span'); whoEl.className='who'; whoEl.textContent = who + '：';
    div.appendChild(whoEl); div.appendChild(document.createTextNode(msg));
    ui.log.appendChild(div); ui.log.scrollTop = ui.log.scrollHeight;
  }
  function updateColorBadges(){
    if (!ui.topBadge || !ui.botBadge) return;
    const tb = ui.topBadge, bb = ui.botBadge;
    if (!colorsAssigned){ tb.textContent='？'; tb.className='color-badge'; bb.textContent='？'; bb.className='color-badge'; return; }
    tb.textContent = state.topColor==='R'?'紅':'黑';
    bb.textContent = state.bottomColor==='R'?'紅':'黑';
    tb.className='color-badge '+(state.topColor==='R'?'red':'black');
    bb.className='color-badge '+(state.bottomColor==='R'?'red':'black');
  }

  // --- 初始化 ---
  function newGame(){
    const bag = [];
    ["R","B"].forEach(color=>{
      bag.push(...mk(color,"G",1), ...mk(color,"A",2), ...mk(color,"E",2), ...mk(color,"R",2), ...mk(color,"N",2), ...mk(color,"C",2), ...mk(color,"P",5));
    });
    shuffle(bag);
    const board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
    let k=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){ board[r][c] = {...bag[k++], r, c, revealed:false}; }
    state = { board, turn:null, bottomColor:'R', topColor:'B', selected:null, history:[], capturedR:[], capturedB:[], quiet:0, winner:null, firstMover:null };
    colorsAssigned = false;
    buildBoardCells();
    renderAll(true);
    updateColorBadges();
    showModal(true);
    setTurnInfo("先手未決定：先手第一步需翻子");
    showThinking(false);
    ui.log.innerHTML='';
  }

  function mk(color, type, count){ return Array.from({length:count}, ()=>({color, type, id:color+type+Math.random().toString(36).slice(2,7)})); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} }

  function buildUI(){
    ui.board = document.getElementById('board');
    ui.topCaps = document.getElementById('topCaps');
    ui.botCaps = document.getElementById('botCaps');
    ui.topName = document.getElementById('topName');
    ui.botName = document.getElementById('botName');
    ui.topBadge = document.getElementById('topBadge');
    ui.botBadge = document.getElementById('botBadge');
    ui.turnInfo = document.getElementById('turnInfo');
    ui.btnNew = document.getElementById('btnNew');
    ui.btnToss = document.getElementById('btnToss');
    ui.btnRule = document.getElementById('btnRule');
    ui.btnResign = document.getElementById('btnResign');
    ui.resultOverlay = document.getElementById('resultOverlay');
    ui.resultText = document.getElementById('resultText');
    ui.btnNew2 = document.getElementById('btnNew2');
    ui.modal = document.getElementById('modal');
    ui.mStartHuman = document.getElementById('mStartHuman');
    ui.mStartAI = document.getElementById('mStartAI');
    ui.mRoll = document.getElementById('mRoll');
    ui.mClose = document.getElementById('mClose');
    ui.modeSel = document.getElementById('mode');
    ui.levelSel = document.getElementById('level');
    ui.log = document.getElementById('log');

    ui.btnNew.onclick = newGame;
    ui.btnNew2.onclick = ()=>{ ui.resultOverlay.style.display='none'; newGame(); };
    ui.btnResign.onclick = resign;
    ui.btnToss.onclick = ()=> showModal(true);
    ui.btnRule.onclick = ()=> showModal(true);
    ui.mClose.onclick = ()=> showModal(false);
    ui.mStartHuman.onclick = ()=> decideFirst('human');
    ui.mStartAI.onclick = ()=> decideFirst('ai');
    ui.mRoll.onclick = ()=> decideFirst(Math.random()<0.5 ? 'human' : 'ai');
    ui.modeSel.onchange = (e)=> { gameMode = e.target.value; renderAll(); if (gameMode==='hva'){ setName(ui.topName,'電腦'); setName(ui.botName,'玩家 1'); } else { setName(ui.topName,'玩家 2'); setName(ui.botName,'玩家 1'); } updateColorBadges(); }
    ui.levelSel.onchange = (e)=> { aiLevel = +e.target.value }
  }

  function buildBoardCells(){
    ui.board.innerHTML='';
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const cell = document.createElement('div'); cell.className='cell'; cell.dataset.r=r; cell.dataset.c=c;
      const coord = document.createElement('div'); coord.className='coord'; coord.textContent=`${r},${c}`;
      cell.appendChild(coord);
      cell.addEventListener('click', onCellClick);
      ui.board.appendChild(cell);
    }
  }

  function decideFirst(who){
    showModal(false);
    if (gameMode==='hva'){ setName(ui.topName,'電腦'); setName(ui.botName,'玩家 1'); }
    else { setName(ui.topName,'玩家 2'); setName(ui.botName,'玩家 1'); }
    state.firstMover = who;
    logAdd(who==='human' ? '你先手：第一步請翻子決定持色' : 'AI 先手：AI 會先翻子決定持色', '系統');
    setTurnInfo( (who==='human') ? '你先手：請翻任一暗棋決定持色' : 'AI先手：AI 正在翻子…');
    colorsAssigned = false;
    if (who==='ai' && gameMode==='hva'){ setTimeout(()=> aiActFirstFlip(), 300); }
  }

  function getMover(){
    if (!colorsAssigned) return state.firstMover || 'human';
    if (gameMode==='pvp') return 'human';
    const turnColor = state.turn;
    const humanColor = state.bottomColor;
    return (turnColor===humanColor) ? 'human' : 'ai';
  }
  function isMyTurnPiece(p){
    if (!p || !p.revealed) return false;
    if (gameMode==='pvp') return p.color===state.turn;
    if (!colorsAssigned) return false;
    const humanTurn = (state.turn === state.bottomColor);
    return humanTurn && (p.color === state.bottomColor);
  }

  function onCellClick(e){
    if (state.winner) return;
    if (gameMode==='hva' && getMover()==='ai') return;
    const r = +e.currentTarget.dataset.r, c = +e.currentTarget.dataset.c;
    const piece = state.board[r][c];

    // 首翻決色
    if (!colorsAssigned){
      if (!piece) return;
      if (!piece.revealed){ firstFlipAssignColors(r,c, 'human'); return; }
      blinkInfo('請先翻一枚暗棋決定持色'); return;
    }

    const sel = state.selected;

    // 點暗棋 → 翻子（單步回合）
    if (piece && !piece.revealed){ doFlip(r,c); return; }

    if (!sel){
      if (piece && isMyTurnPiece(piece)){ state.selected={r,c}; renderAll(); return; }
      return;
    } else {
      if (sel.r===r && sel.c===c){ state.selected=null; renderAll(); return; }
      const fromP = state.board[sel.r][sel.c]; if (!fromP || !fromP.revealed){ state.selected=null; renderAll(); return; }
      // 空格 → 移動一步
      if (!piece){ if (isAdjacent(sel.r, sel.c, r, c)){ doMove(sel.r, sel.c, r, c); } else blinkInfo('只能移動一格'); return; }
      // 敵棋 → 吃
      if (piece && piece.revealed && piece.color!==fromP.color){ if (canCapture(sel.r, sel.c, r, c)){ doCapture(sel.r, sel.c, r, c); } else blinkInfo('此路不通'); return; }
      // 己棋 → 切換選擇
      if (piece && piece.revealed && piece.color===fromP.color){ state.selected={r,c}; renderAll(); return; }
    }
  }

  function aiActFirstFlip(){
    const ds = darkSquares();
    const pick = ds[Math.floor(Math.random()*ds.length)];
    firstFlipAssignColors(pick.r, pick.c, 'ai');
  }

  function darkSquares(){ const arr=[]; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){ const p=state.board[r][c]; if (p && !p.revealed) arr.push({r,c}); } return arr; }

  function firstFlipAssignColors(r,c, who){
    const p = state.board[r][c]; if(!p || p.revealed) return;
    p.revealed = true; colorsAssigned = true;
    state.bottomColor = (who==='human') ? p.color : (p.color==='R'?'B':'R');
    state.topColor = (state.bottomColor==='R'?'B':'R');
    state.turn = (p.color==='R'?'B':'R'); // 翻子後換對手
    state.selected = null; state.quiet = 0;
    logAdd((who==='human'?'你':'AI') + '翻到『' + (p.color==='R'?'紅':'黑') + CN[p.color==='R'?'R':'B'][p.type] + '』，你持『' + (state.bottomColor==='R'?'紅':'黑') + '』', (who==='human'?'你':'AI'));
    renderAll(); updateColorBadges();
    const msg = (who==='human') ? `你翻到【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】→ 你持【${state.bottomColor==='R'?'紅':'黑'}】；輪到對手`
                                : `AI 翻到【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】→ 你持【${state.bottomColor==='R'?'紅':'黑'}】；輪到你`;
    setTurnInfo(msg);
    if (getMover()==='ai'){ setTimeout(aiMove, 220); showThinking(true); } else { showThinking(false); }
  }

  // --- 移動 / 吃 / 規則判定 ---
  function isAdjacent(r1,c1,r2,c2){ return Math.abs(r1-r2) + Math.abs(c1-c2) === 1; }
  function isCannon(p){ return p?.type==='C' }
  function betweenCount(r1,c1,r2,c2){
    if (r1!==r2 && c1!==c2) return Infinity;
    let cnt=0;
    if (r1===r2){ const [a,b] = c1<c2 ? [c1,c2] : [c2,c1]; for (let x=a+1;x<b;x++) if (state.board[r1][x]) cnt++; }
    else { const [a,b] = r1<r2 ? [r1,r2] : [r2,r1]; for (let y=a+1;y<b;y++) if (state.board[y][c1]) cnt++; }
    return cnt;
  }
  function canCapture(r1,c1,r2,c2){
    const a = state.board[r1][c1], b = state.board[r2][c2];
    if (!a || !b || !a.revealed || !b.revealed || a.color===b.color) return false;
    if (isCannon(a)){ if (r1!==r2 && c1!==c2) return false; return betweenCount(r1,c1,r2,c2)===1; }
    if (!isAdjacent(r1,c1,r2,c2)) return false;
    if (a.type==='P' && b.type==='G') return true;
    if (a.type==='G' && b.type==='P') return false;
    return RANK[a.type] >= RANK[b.type];
  }
  function doFlip(r,c){
    const p = state.board[r][c]; if(!p || p.revealed) return;
    p.revealed = true; state.quiet = 0; logAdd(`${sideLabel()} 翻開了【${p.color==='R'?'紅':'黑'}${CN[p.color==='R'?'R':'B'][p.type]}】`, sideLabel());
    renderAll(); nextTurn();
  }
  function doMove(r1,c1,r2,c2){
    const a = state.board[r1][c1]; if(!a) return;
    if (!isAdjacent(r1,c1,r2,c2)) return; if (state.board[r2][c2]) return;
    state.board[r2][c2] = {...a, r:r2, c:c2}; state.board[r1][c1] = null;
    state.selected = null; state.quiet++; logAdd(`${sideLabel()} 將【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】從 (${r1},${c1}) 移到 (${r2},${c2})`, sideLabel());
    renderAll(); nextTurn();
  }
  function doCapture(r1,c1,r2,c2){
    const a = state.board[r1][c1], b = state.board[r2][c2]; if(!a||!b) return;
    if (!canCapture(r1,c1,r2,c2)) return;
    const taken = {...b};
    state.board[r2][c2] = {...a, r:r2, c:c2}; state.board[r1][c1] = null;
    (taken.color==='R' ? state.capturedR : state.capturedB).push(taken);
    state.selected = null; state.quiet = 0; logAdd(`${sideLabel()} 以【${a.color==='R'?'紅':'黑'}${CN[a.color==='R'?'R':'B'][a.type]}】吃掉【${b.color==='R'?'紅':'黑'}${CN[b.color==='R'?'R':'B'][b.type]}】`, sideLabel());
    renderAll(); nextTurn();
  }

  // --- AI ---
  function aiMove(){
    // 時控：依等級設定思考時長與最大深度
    const budgets = [{ms:350, maxD:4}, {ms:900, maxD:6}, {ms:1800, maxD:8}];
    const cfg = budgets[Math.max(0, Math.min(2, aiLevel))];
    const start = nowMs(), deadline = start + cfg.ms;
    showThinking(true);
    try{
      if (state.winner) return;
      const color = state.turn;
      // 迭代加深
      let best=null, bestVal=-1e9;
      const rootHash = hashPos(state);
      for (let d=1; d<=cfg.maxD; d++){
        const res = searchBest(state, d, color, -1e9, 1e9, deadline, 0);
        if (res.aborted) break;
        if (res.move) { best=res.move; bestVal=res.value; }
        if (nowMs() > deadline) break;
      }
      // 超時或沒有結果 → 保底：隨機合法行動或翻子
      if (!best){
        let moves = generateAllActions(color);
        if (!moves.length){
          const ds = darkSquares();
          if (ds.length){
            const k = ds[Math.floor(Math.random()*ds.length)];
            best = {kind:'flip', r:k.r, c:k.c};
          }
        } else {
          best = moves[0];
        }
      }
      if (best) applyAction(best, true);
    } catch(e){
      console.error('AI error', e);
      const ds = darkSquares(); if (ds.length){ const k=ds[Math.floor(Math.random()*ds.length)]; applyAction({kind:'flip', r:k.r, c:k.c}, true); } else { nextTurn(); }
    } finally { showThinking(false); }
  }

  // 帶 TT 的 negamax + quiescence
  function searchBest(s0, depth, color, alpha, beta, deadline, ply){
    if (nowMs() > deadline) return {aborted:true};
    const hash = hashPos(s0);
    const tte = TT.get(hash);
    if (tte && tte.depth>=depth) {
      if (tte.flag==='EXACT') return {move:tte.move, value:tte.value};
      else if (tte.flag==='LOWER' && tte.value>alpha) alpha = tte.value;
      else if (tte.flag==='UPPER' && tte.value<beta) beta = tte.value;
      if (alpha>=beta) return {move:tte.move, value:tte.value};
    }
    if (depth===0) return {move:null, value: quiescence(s0, color, alpha, beta, deadline, ply)};

    let best=null, bestVal=-1e9;
    const moves = generateAllActions(color);
    if (!moves.length){
      // 若沒有行動但仍有暗子，可視為弱回合；返回評估
      return {move:null, value: evaluate(s0, color)};
    }

    // 殺手著法排序
    const killers = KILLERS[ply]||[];
    for (const m of moves){ const key = JSON.stringify(m); if (killers.find(k=>JSON.stringify(k)===key)) m._order = (m._order||0) + 20000; }
    moves.sort((a,b)=> (b._order||0) - (a._order||0));

    for (const m of moves){
      const snap = snapshot(s0);
      applyAction(m, false, snap);
      const opp = color==='R'?'B':'R';
      const res = searchBest(snap, depth-1, opp, -beta, -alpha, deadline, ply+1);
      if (res.aborted) return {aborted:true};
      const val = -res.value;
      if (val>bestVal){ bestVal=val; best=m; }
      if (val>alpha) alpha=val;
      if (alpha>=beta){
        // 記錄 killer / history
        if (m.kind!=='flip'){ (KILLERS[ply]=KILLERS[ply]||[]).unshift(m); KILLERS[ply]=KILLERS[ply].slice(0,2); HISTORY[histKey(m)]=(HISTORY[histKey(m)]||0)+depth*depth; }
        break;
      }
    }
    // 寫入 TT
    let flag='EXACT';
    if (bestVal<=alpha) flag='UPPER';
    else if (bestVal>=beta) flag='LOWER';
    TT.set(hash, {depth, value:bestVal, move:best, flag});
    return {move:best, value:bestVal};
  }

  // 靜態搜尋：只拓展吃子（含炮隔吃），避免地平線效應
  function quiescence(s0, color, alpha, beta, deadline, ply){
    const stand = evaluate(s0, color);
    if (stand>alpha) alpha=stand;
    if (alpha>=beta) return alpha;
    const caps = [];
    for (let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const a = s0.board[r][c];
      if (!a || !a.revealed || a.color!==color) continue;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,dc] of dirs){
        const nr=r+dr, nc=c+dc; if (!inBoard(nr,nc)) continue;
        const b = s0.board[nr][nc];
        if (b && b.revealed && b.color!==color && canCapture(r,c,nr,nc)) caps.push({kind:'capture', from:{r,c}, to:{r:nr,c:nc}});
      }
      if (s0.board[r][c].type==='C'){
        const more = legalCapturesFrom(r,c,color);
        for (const m of more) caps.push({kind:'capture', from:m.from, to:m.to});
      }
    }
    // 排序：MVV-LVA
    caps.sort((a,b)=>{
      const av = PIECE_VALUES[s0.board[a.to.r][a.to.c].type] - PIECE_VALUES[s0.board[a.from.r][a.from.c].type]*0.8;
      const bv = PIECE_VALUES[s0.board[b.to.r][b.to.c].type] - PIECE_VALUES[s0.board[b.from.r][b.from.c].type]*0.8;
      return bv-av;
    });
    for (const m of caps){
      if (nowMs()>deadline) break;
      const snap = snapshot(s0);
      applyAction(m, false, snap);
      const val = -quiescence(snap, color==='R'?'B':'R', -beta, -alpha, deadline, ply+1);
      if (val>alpha) alpha=val;
      if (alpha>=beta) break;
    }
    return alpha;
  }

  // 更強的評估：物質 + 中心 + 王兵特例 + 翻子資訊值 + 受攻懲罰
  function evaluate(snap, povColor){
    let matR=0, matB=0, centR=0, centB=0, atkR=0, atkB=0;
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const p = snap.board[r][c]; if (!p) continue;
      if (p.revealed){
        const cent = 8 - (Math.abs(r-1.5)+Math.abs(c-3.5));
        if (p.color==='R'){ matR+=PIECE_VALUES[p.type]; centR+=cent; }
        else { matB+=PIECE_VALUES[p.type]; centB+=cent; }
      }
    }
    // 粗略受攻：若相鄰被更大子威脅，扣分
    function threats(color){
      let t=0;
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
        const a = snap.board[r][c]; if (!a || !a.revealed || a.color!==color) continue;
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc; if (!inBoard(nr,nc)) continue;
          const b=snap.board[nr][nc];
          if (b && b.revealed && b.color!==(color)){
            if (b.type==='P' && a.type==='G') t+=80;
            else if (a.type==='P' && b.type==='G') t-=40;
            else if (RANK[b.type]>RANK[a.type]) t+= (PIECE_VALUES[b.type]-PIECE_VALUES[a.type])*0.05;
          }
        }
      }
      return t;
    }
    atkR = threats('R'); atkB = threats('B');

    // 翻子資訊值（暗子越多，越有潛在價值）
    let dark=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){ const p=snap.board[r][c]; if (p && !p.revealed) dark++; }
    const info = Math.min(40, dark*0.7);

    const val = (matR-matB) + 0.12*(centR-centB) - 0.1*(atkR-atkB) + info*0.02;
    return (povColor==='R') ? val : -val;
  }

  function snapshot(s){ return { board: s.board.map(row=> row.map(p=> p? {...p}:null )), turn:s.turn, bottomColor:s.bottomColor, topColor:s.topColor, selected:s.selected? {...s.selected}:null, history:[], capturedR:s.capturedR.map(x=>({...x})), capturedB:s.capturedB.map(x=>({...x})), quiet:s.quiet, winner:s.winner, firstMover:s.firstMover }; }

  // 勝負/和局
  function checkEnd(){
    if (state.winner) return;
    const aliveR = countAlive('R'), aliveB = countAlive('B');
    if (aliveR===0 || aliveB===0){ state.winner = (aliveR===0)? 'B':'R'; setTurnInfo(`${state.winner==='R'?'紅':'黑'}勝（全殲）`); showResult(`${state.winner==='R'?'紅':'黑'}勝（全殲）`); renderAll(); return; }
    if (state.quiet >= MAX_QUIET){ state.winner = 'D'; setTurnInfo('和局（50手無吃無翻）'); showResult('和局（50手無吃無翻）'); renderAll(); return; }
    const darks = darkSquares(); const hasMoves = generateAllActions(state.turn).length>0;
    if (darks.length===0 && !hasMoves){ state.winner = (state.turn==='R'?'B':'R'); setTurnInfo(`${state.winner==='R'?'紅':'黑'}勝（對方無法行棋）`); showResult(`${state.winner==='R'?'紅':'黑'}勝（對方無法行棋）`); renderAll(); return; }
  }
  function showResult(text){ ui.resultText.textContent = text + '　點「新局」再來一盤！'; ui.resultOverlay.style.display='flex'; }

  function countAlive(color){ let n=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){ const p = state.board[r][c]; if (p && p.color===color) n++; } return n; }

  // 繪製
  function renderAll(initial=false){ renderBoard(); renderCaptured(); if (initial) renderNames(); }
  function renderNames(){ ui.topName.style.color = state.topColor==='R'? 'var(--red)':'var(--black)'; ui.botName.style.color = state.bottomColor==='R'? 'var(--red)':'var(--black)'; updateColorBadges(); }
  function renderCaptured(){
    function pack(list){ const m = new Map(); for (const p of list){ const key=p.color+p.type; m.set(key,(m.get(key)||0)+1); }
      const arr=[]; for(const [k,v] of m.entries()){ const color=k[0]==='R'?'R':'B'; const type=k[1]; arr.push({color,type,count:v}); } arr.sort((a,b)=> PIECE_VALUES[b.type]-PIECE_VALUES[a.type]); return arr; }
    const topTaken = (state.topColor==='R') ? state.capturedR : state.capturedB;
    const botTaken = (state.bottomColor==='R') ? state.capturedR : state.capturedB;
    ui.topCaps.innerHTML=''; for(const x of pack(topTaken)){ const el=document.createElement('div'); el.className='cap '+(x.color==='R'?'red':'black'); el.textContent = CN[x.color==='R'?'R':'B'][x.type]; const s=document.createElement('small'); s.textContent='×'+x.count; el.appendChild(s); ui.topCaps.appendChild(el); }
    ui.botCaps.innerHTML=''; for(const x of pack(botTaken)){ const el=document.createElement('div'); el.className='cap '+(x.color==='R'?'red':'black'); el.textContent = CN[x.color==='R'?'R':'B'][x.type]; const s=document.createElement('small'); s.textContent='×'+x.count; el.appendChild(s); ui.botCaps.appendChild(el); }
  }
  function renderBoard(){
    const cells = ui.board.children;
    for (const cell of cells) cell.classList.remove('sel','hint','target');
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++){
      const idx = r*COLS+c; const cell = cells[idx]; cell.innerHTML='';
      const coord = document.createElement('div'); coord.className='coord'; coord.textContent=`${r},${c}`; cell.appendChild(coord);
      const p = state.board[r][c];
      if (p){
        const k = document.createElement('div');
        if (!p.revealed){ k.className='piece back'; }
        else { k.className='piece revealed '+(p.color==='R'?'red':'black'); const lab=document.createElement('span'); lab.className='piece-label'; lab.textContent = (p.color==='R'? CN.R[p.type] : CN.B[p.type]) || p.type; k.appendChild(lab); }
        cell.appendChild(k);
      }
    }
    if (state.selected){
      const {r,c} = state.selected; const idx = r*COLS+c; cells[idx].classList.add('sel');
      const p = state.board[r][c];
      if (p && p.revealed){
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc; if (!inBoard(nr,nc)) continue;
          const b = state.board[nr][nc];
          if (!b) cells[nr*COLS+nc].classList.add('hint');
          else if (b.revealed && b.color!==p.color && canCapture(r,c,nr,nc)) cells[nr*COLS+nc].classList.add('target');
        }
        if (p.type==='C'){ const caps = legalCapturesFrom(r,c,p.color); for (const m of caps){ cells[m.to.r*COLS+m.to.c].classList.add('target'); } }
      }
    }
  }

  function nextTurn(){
    state.turn = (state.turn==='R' ? 'B' : 'R');
    state.selected = null;
    showThinking(false);
    checkEnd();
    if (!state.winner){
      const mover = getMover();
      setTurnInfo( mover==='human' ? '輪到你' : 'AI 思考中…' );
      showThinking(mover!=='human');
      renderAll();
      if (mover==='ai'){ setTimeout(aiMove, 220); }
    }
  }

  // 認輸
  function resign(){
    if (state.winner) return;
    const loserColor = state.turn;
    const winner = (loserColor==='R'?'B':'R');
    state.winner = winner;
    const text = `你認輸，${winner==='R'?'紅':'黑'}勝。`;
    setTurnInfo(text);
    logAdd('認輸', '你');
    showResult(text);
    renderAll();
  }

  // 啟動
  function init(){ buildUI(); newGame(); }
  function renderNames(){ ui.topName.style.color = state.topColor==='R'? 'var(--red)':'var(--black)'; ui.botName.style.color = state.bottomColor==='R'? 'var(--red)':'var(--black)'; updateColorBadges(); }

  // 輔助：生成/搜尋會用到
  function manhattan(r,c, r2,c2){ return Math.abs(r-r2)+Math.abs(c-c2) }

  init();
})();
</script>
</body>
</html>
